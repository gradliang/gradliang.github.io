{"meta":{"title":"码兵之家","subtitle":"公仔的个人博客站","description":"公仔的个人博客站","author":"码兵之家 - 公仔","url":"https://www.code64.cn/blog1","root":"/blog1/"},"pages":[],"posts":[{"title":"GNU 连接器 ld 的使用指南","slug":"GNU-连接器-ld-的使用指南","date":"2021-10-03T10:50:42.000Z","updated":"2022-02-24T14:35:47.194Z","comments":true,"path":"2021/10-03/0661E6A88B533CE14E03343293F9BDD8/","link":"","permalink":"https://www.code64.cn/blog1/2021/10-03/0661E6A88B533CE14E03343293F9BDD8/","excerpt":"","text":"ld 是 GNU 的连接器，用于将多个已经编译好的 .o 文件连接成可执行文件或者动态库。 一般使用方式如下： ld [参数选项] -o [输出文件名] obj_file1.o obj_file2.o obj_file3.o ... 例如，.a 库文件可以跟 .o 文件一起列出来： ld -o main crt0.o obj1.o obj2.o libq1.a 以上例的 libq1.a 可以用 -l 选项指定: ld -o main crt0.o obj1.o obj2.o -lq1 gcc/g++ 也可以直接调用 ld 加选项进行连接，例如： ld -e start1 obj1.o obj2.o # 指定 start1 符号为程序入口点 # 换成 gcc 来使用的话，采用 -Wl 选项来传递连接选项参数 : # gcc -Wl,-e,start1 obj1.o obj2.o 常用的 ld 的选择项有： 选项 解释 -e address --entry address 设置程序的执行入口点 -EB 连接对象文件为大端字节序 -EL 连接对象文件为小端字节序 -A arch 指定 CPU 架构 -b target --format target 指定输入文件的格式 -h filename -soname filename 设置共享库的内部名字 -I program --dynamic-linker program 设置动态连接解释程序名称 --no-dynamic-linker 可执行文件不需要动态连接解释程序设置 -l libname --library libname 指出连接需要的库的名称 -L directory--library-path directory 指出库文件的搜索路径 -o filename--output filename 设置输出文件名 -s--strip-all 去除所有符号 -S--strip-debug 去除调试用的符号 --strip-discarded 去除标记为 discarded 段中的符号 -T filename--script filename 读取连接器脚本 -Bdynamic-dy-call_shared 使用共享库来连接 -Bstatic-dn-non_shared-static 使用静态库来连接 -init symbol 设置在装载时调用指定符号 -Map FILE/DIR 写入map到文件或者目录 -nostdlib 仅仅连接命令行中指定的库，不连接其他标准库 --oformat TARGET 支持输出文件的格式 -rpath PATH 设置程序运行时，动态库的搜索路径 -rpath-link PATH 设置连接时，动态库的搜索路径 -shared-Bshareable 生成共享库 -pie--pic-executable 生成位置无关代码的可执行文件","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"Linux","slug":"技术文章/Linux","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.code64.cn/blog1/tags/Linux/"}]},{"title":"使用 GNU gettext 实现程序的多国语言本地化","slug":"使用-GNU-gettext-实现程序的多国语言本地化","date":"2021-06-13T02:57:38.000Z","updated":"2022-02-24T14:35:47.194Z","comments":true,"path":"2021/06-13/59FA5670CBB6D1AE7BD50A5887B8C1AD/","link":"","permalink":"https://www.code64.cn/blog1/2021/06-13/59FA5670CBB6D1AE7BD50A5887B8C1AD/","excerpt":"","text":"使用 GNU gettext 实现程序的多国语言本地化1. 基本操作gettext 是 GNU 出品的一个项目，主要用于将应用程序本地化和国际化的一个实用套件。 首先，我们的程序，如果在源代码中写死了字符串，则我们无法对这个字符串进行国际化和本地化，例如： int main() &#123; printf(&quot;hello world. \\n&quot;); &#125; 上面的程序，无论在什么语言版本的系统中，其显示的都是英文的字符串 “hello world” 。 gettext 的方法是，需要进行国际化与本地化的字符串中，全部加上一个叫 gettext() 的函数调用，如下： // a1.c #include &lt;stdio.h&gt; #include &lt;libintl.h&gt; #include &lt;locale.h&gt; #define PACKAGE &quot;test1&quot; // 语言字符串资源包名 int main() &#123; setlocale(LC_ALL, &quot;&quot;); bindtextdomain(PACKAGE, &quot;locale&quot;); textdomain(PACKAGE); printf(&quot;%s\\n&quot;, gettext(&quot;I come from China.&quot;)); printf(&quot;%s\\n&quot;, gettext(&quot;I like Java language.&quot;)); // 上面的 gettext() 可以用宏来代替，进行简化，例如: // #define _(str) gettext(str) // #define N(str) gettext(str) // 等等 return 0; &#125; // 使用如下命令编译： // gcc -o a1 a1.c 上面示范程序中的字符串 “I come from China.” 和 “I like Java language.” ，在使用之前都加上了 gettext() 函数进行包裹。gettext() 函数的作用是：以原始字符串作为 key，去加载并获取到并返回其对应语言的的本地字符串。 使用 xgettext 命令，将源文件中被 gettext() 函数包裹的字符串全部抓出来，命令如下（用 test1 作为语言包名）： xgettext a1.c -o test1.po xgettext 命令可以指定多个原文文件，输出的 .po 文件是一个文本文件，里面包含了需要翻译的所有字符串，文件名是上面源码中指定的对应的语言资源包 PACKAGE 名。 打开 test1.po 文件，把字符编码设置为 UTF-8，将里面的 &quot;Content-Type: text/plain; charset=CHARSET\\n&quot; 改为 &quot;Content-Type: text/plain; charset=UTF-8\\n&quot;。然后，对相应的文本进行翻译： #: a1.c:13 msgid &quot;I come from China.&quot; msgstr &quot;&quot; #: a1.c:14 msgid &quot;I like Java language.&quot; msgstr &quot;&quot; 上面的 msgid 就是原始字符串，作为 key，不要修改，下面的 msgstr 则应该修改，将翻译过去的文本填进去，如下： #: a1.c:13 msgid &quot;I come from China.&quot; msgstr &quot;我来自中国。&quot; #: a1.c:14 msgid &quot;I like Java language.&quot; msgstr &quot;我喜欢 Java 语言&quot; 然后使用 msgfmt 命令将 .po 文件编译为 gettext() 函数可以识别的 .mo 文件，命令如下： msgfmt test1.po -o test1.mo 由于上面 C 程序中指定了 .mo 资源的加载路径，语句 bindtextdomain(PACKAGE, &quot;locale&quot;); 指定了 .mo 存放在当前目录的 locale 子目录下面。所以，把生成的 test1.mo 文件放在当前目录的如下路径下： locale/zh_CN/LC_MESSAGES/test1.mo 这里假设系统为简体中文，当前 locale 设置为 zh_CN，上面 C 程序的语句 setlocale(LC_ALL, &quot;&quot;); 就是使用系统默认的语言环境。执行上面 C 程序 ./a1 得到结果为： 我来自中国。 我喜欢 Java 语言 上面例子说明了 gettext 套件的基本使用流程。 2. 批量操作xgettext 命令可以一次性指定多个输入源文件，如： xgettext a1.c a2.c a3.c -o package.po xgettext 命令也可以通配符，如： xgettext *.c -o package.po 可以把所有需要提取的源文件放在一个列表中（list1.txt 中列出所有源文件名）： xgettext -f list1.txt -o package.po 增加其他关键字，例如 增加 N() 函数，则 N(“string”) 也会被抓取： xgettext *.c -kN -o package.po 如果已经翻译好了字符串，后来源代码发生了更改，增加了一些新的字符串，可以使用 -j 选项，把新增的字符串追加到已经存在的翻译好的 .po 文件中，例如： xgettext a1.c a2.c a3.c -j -o package.po 用 msginit 命令可以把 xgettext 生成的 .po 文件（POT）转换成对应语言的翻译文本 .po （会修改好一些编码与语言的相关字段）： msginit --no-translator --locale zh_CN -o package_new.po -i package.po 可以用 msgmerge 命令把新生成的 .po 合并到已经翻译好的 .po 文件中： msgmerge -o package.po locale/zh_CN/LC_MESSAGES/package.po package.po","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"Linux","slug":"技术文章/Linux","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.code64.cn/blog1/tags/Linux/"}]},{"title":"Windows 下如何将标准输出设置为 UTF-8 编码","slug":"Windows-下如何将标准输出设置为-UTF-8-编码","date":"2021-06-10T01:05:37.000Z","updated":"2022-02-24T14:35:47.194Z","comments":true,"path":"2021/06-10/DE1E7A72CAC1E21D674A76C3D093CAB3/","link":"","permalink":"https://www.code64.cn/blog1/2021/06-10/DE1E7A72CAC1E21D674A76C3D093CAB3/","excerpt":"","text":"Windows 下如何将控制台的标准输出设置为 UTF-8 编码C# 语言C# 语言在简体中文版的 Windows 下默认使用 GBK 编码。 切换标准输入输出的字符编码只需要设置 Console 对象的输出字符编码即可。在代码最初处加上 Console.OutputEncoding = System.Text.Encoding.UTF8 。上例子： using System; namespace ConsoleApp &#123; class Program &#123; static void Main(string[] args) &#123; Console.OutputEncoding = System.Text.Encoding.UTF8; // 关键这句 Console.WriteLine(&quot;Hello World! 测试中文输出的 UTF-8 字符串&quot;); &#125; &#125; &#125; 编译成 ConsoleApp.exe，然后在命令行中执行 ConsoleApp.exe，可以看到，正常输出中文字，不会乱码。然后执行： ConsoleApp.exe &gt; a.txt 把输出结果重定向到 a.txt 文件中，用编辑器打开 a.txt，可以在编辑器中看到文件编码为 UTF-8 。 C/C++ 语言简体中文版的Windows 控制台输出的字符 CodePage 为 GBK。在需要输出 UTF-8 文本到标准输出之前，先调用 Windows API 进行设置，使用 SetConsoleOutputCP 这个 API 来先设置控制台输出的 CodePage 为 UTF-8。上例子： // u8test.cpp, 这个源代码要保存为 UTF-8 编码 #include &lt;stdio.h&gt; #include &lt;iostream&gt; #include &lt;Windows.h&gt; int main() &#123; SetConsoleCP(CP_UTF8); SetConsoleOutputCP(CP_UTF8); printf(&quot;中文字符串1 \\n&quot;); // C 风格的标准输出 std::cout &lt;&lt; &quot;中文字符串2&quot; &lt;&lt; std::endl; // C++ 风格的 I/O 流输出 &#125; SetConsoleCP 函数用于设置标准输入的字符编码 CodePage SetConsoleOutputCP 函数用于设置标准输出的字符编码 CodePage 用 mingw gcc 编译的命令： g++ -s -o u8test.exe u8test.cpp 用 VC++ 编译则需要加上 -utf-8 命令参数，如果不加上 -utf-8 的话，编译器会把字符串的编码默认转换为 GBK。（ -utf-8 命令行参数仅仅在 VC++ 2015版本以上才有效 ） cl -MD -utf-8 u8test.cpp Go / Rust 语言这些新兴语言没有历史包袱，标准库已经默认将标准输入输出的字符编码设置为 UTF-8 了，所以不需要过多关注这些，直接开干使用即可。","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"Win32","slug":"技术文章/Win32","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Win32/"}],"tags":[{"name":"Win32","slug":"Win32","permalink":"https://www.code64.cn/blog1/tags/Win32/"}]},{"title":"Node.js 使用 PM2 管理进程","slug":"Node-js-使用-PM2-管理进程","date":"2021-05-30T02:38:47.000Z","updated":"2022-02-24T14:35:47.194Z","comments":true,"path":"2021/05-30/A1F112420F18A412B067B4C27C904C33/","link":"","permalink":"https://www.code64.cn/blog1/2021/05-30/A1F112420F18A412B067B4C27C904C33/","excerpt":"","text":"执行 Node.js 的程序，需要使用命令行进行调用： node js-module-name 当 Ctrl + C 退出之后，或者关闭了终端之后，Node.js 的进程也随之被退出了。如果 Node.js 的程序中途出现了异常，也会退出进程。如果部署在服务器上面的 Node.js 应该需要以守护进程的方式进行启动的话，则需要借助一些工具才能完成这种操作。 PM2 就是一款 Node.js 应用的极佳的进程管理器。官方网址是： https://pm2.keymetrics.io/。 安装方法如下： npm install -g pm2 安装完毕之后，需要查看帮助，请输入： pm2 -h 启动一个 Node.js 进程并守护，使用以下命令： pm2 start ex21.js 这时进程启动并进入后台管理，并输出下面进程信息。加上 --watch 参数在后面，意味着当应用程序发生异常时，pm2会帮你重启服务。 [PM2] Starting G:\\mystudy\\node\\1\\ex21.js in fork_mode (1 instance) [PM2] Done. ┌─────┬─────────┬─────────────┬─────────┬─────────┬──────────┬────────┬──────┬───────────┬──────────┬──────────┬──────────┬──────────┐ │ id │ name │ namespace │ version │ mode │ pid │ uptime │ ↺ │ status │ cpu │ mem │ user │ watching │ ├─────┼─────────┼─────────────┼─────────┼─────────┼──────────┼────────┼──────┼───────────┼──────────┼──────────┼──────────┼──────────┤ │ 0 │ ex21 │ default │ N/A │ fork │ 15332 │ 0s │ 0 │ online │ 0% │ 27.7mb │ o_o │ disabled │ └─────┴─────────┴─────────────┴─────────┴─────────┴──────────┴────────┴──────┴───────────┴──────────┴──────────┴──────────┴──────────┘ 即使命令终端窗口关闭了，进程还是会在后台继续运行。以上信息中，可以看出，进程 ID 为：15332，这个进程在进程列表中的 ID 为 0。 结束一个进程，可以使用下面命令（以上面的进程为例子，命令中的 id 为列表中的 ID）： pm2 stop 0 如果要把列表中所有的进程都停止，则使用： pm2 stop all 查看完成进程列表，使用命令： pm2 list ┌─────┬─────────┬─────────────┬─────────┬─────────┬──────────┬────────┬──────┬───────────┬──────────┬──────────┬──────────┬──────────┐ │ id │ name │ namespace │ version │ mode │ pid │ uptime │ ↺ │ status │ cpu │ mem │ user │ watching │ ├─────┼─────────┼─────────────┼─────────┼─────────┼──────────┼────────┼──────┼───────────┼──────────┼──────────┼──────────┼──────────┤ │ 0 │ ex21 │ default │ N/A │ fork │ 0 │ 0 │ 0 │ stopped │ 0% │ 0b │ o_o │ disabled │ └─────┴─────────┴─────────────┴─────────┴─────────┴──────────┴────────┴──────┴───────────┴──────────┴──────────┴──────────┴──────────┘ 重启进程，则使用命令： pm2 restart 0 重启所有进程，则使用命令： pm2 restart all 将进程从管理列表中删除，使用命令： pm2 delete 0 将所有进程从管理列表中删除，使用命令： pm2 delete all","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"JavaScript","slug":"技术文章/JavaScript","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.code64.cn/blog1/tags/JavaScript/"}]},{"title":"Node.js Windows平台下多版本共存的方法","slug":"Node-js-Windows平台下多版本共存的方法","date":"2021-05-26T02:21:26.000Z","updated":"2022-02-24T14:35:47.194Z","comments":true,"path":"2021/05-26/C3A70A5614ED50A3FB175C56BEA4464D/","link":"","permalink":"https://www.code64.cn/blog1/2021/05-26/C3A70A5614ED50A3FB175C56BEA4464D/","excerpt":"","text":"本文所描述的方法，是以绿色软件的安装方法来实现，Node.js 在 Windows 下多个不同版本共存。不同的版本放在不同的目录下，通过设置不同的 PATH 环境变量来实现。不同目录下的 Node.js 拥有不同的 exe 版本和相互独立的 npm 包。 该方法在其它操作系统也可以通用。 首先，去 https://nodejs.org/en/ 下载你需要的版本： 选择 All download options : 选择绿色软件包，解压即用的那种，下图的 node-v16.2.0-win-x64.7z 和 node-v16.2.0-win-x64.zip 都可以，只是压缩格式不一样: 解压到自己喜欢存放的目录，任何目录都可以；我这里以 D:\\GreenSoft\\Node\\node-v16 目录作例子进行说明： 在 Node.js 程序根目录 D:\\GreenSoft\\Node\\node-v16 目录中 （本文以 D:\\GreenSoft\\Node\\node-v16 为例子作说明）: 先新建一个目录，名叫 cache，用于存放 npm 安装缓存。 再新建一个文本文件，名字叫 npmrc，配置 npm 的安装路径，内容如下： prefix=D:\\GreenSoft\\Node\\node-v16 cache=D:\\GreenSoft\\Node\\node-v16\\cache 如果想全局使用淘宝镜像源，可以加上： registry=https://registry.npm.taobao.org 然后，再复制 npmrc 到 D:\\GreenSoft\\Node\\node-v16\\node_modules\\npm 中。 真正起作用的配置文件是位于 node_modules\\npm 中的这份，在 Node.js 程序根目录的那份配置文件只是用于备份。 如果升级了 npm 的话， node_modules\\npm 中的 npmrc 可能会被删除，这时只需把 Node.js 程序根目录中的 npmrc 复制到 node_modules\\npm 中即可。 下面说明如何创建快捷方式： 在 Node.js 程序根目录 D:\\GreenSoft\\Node\\node-v16 目录创建一个批处理文件，名叫：setenv.bat，内容如下： @echo off set PATH=D:\\GreenSoft\\Node\\node-v16;%PATH% cls 在桌面或者开始菜单中，右键创建一个快捷方式，指向 D:\\GreenSoft\\Node\\node-v16\\setenv.bat。 然后，右键 –&gt; 属性，把快捷方式的属性修改如下（主要是在 bat 文件路径前面加上 cmd /K ，同时也可以修改起始位置）： 双击刚才修改好的快捷方式，输入运行 node -v 和 npm -v，看看版本号是否正常，如果正常显示，则表示安装成功。 C:\\&gt;node -v v16.2.0 C:\\&gt;npm -v 7.14.0 C:\\&gt; 有时候会遇到使用 npm 来更新安装 npm 会失败的情况，也就是 npm install -g npm 会报错的情况。这时可以借用 cnpm 来更新，如下： npm install -g cnpm --registry=https://registry.npm.taobao.org cnpm install -g npm 更新完 npm 之后，记得把 Node.js 程序根目录下的 npmrc 文件复制回 node_modules\\npm 中。 结尾处上个图让大伙养养眼！","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"JavaScript","slug":"技术文章/JavaScript","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.code64.cn/blog1/tags/JavaScript/"}]},{"title":"Rust 语法简明总结","slug":"Rust-语法简明总结","date":"2021-04-02T03:18:06.000Z","updated":"2022-02-24T14:35:47.194Z","comments":true,"path":"2021/04-02/D285A33A84DBDB29D0FE1E420D07D2FD/","link":"","permalink":"https://www.code64.cn/blog1/2021/04-02/D285A33A84DBDB29D0FE1E420D07D2FD/","excerpt":"","text":"Rust 语法简明总结该文是简单精要地阐明一下 Rust 语言的一些基本语法。不是要把语法写成书，长编大论；也不是一些简单的笔记，随便写写。本文只是想以最简单的语言文字，尽量简单地把 Rust 这门被有些人称为最难的编程语言，简明地总结出来。 Hello Worldfn main() &#123; // fn 定义一个函数，程序从 main 函数开始执行 println!(&quot;Hello World.&quot;); // 使用 println 宏打印一行字符串，! 叹号结尾表示 println 是一个宏 &#125; 变量与类型变量声明变量必须先绑定再使用，绑定的声明方式如下（其他语言的变量是声明，但是 Rust 的变量是一种资源的绑定关系）： let x : i32 = 100; // 定义只读的变量 x，类型为 i32，并初始化为 100 let mut y : i32 = 200; // 定义可写的变量 y，类型为 i32，并初始化为 200 const z : i32 = 300; // 定义常量 z，类型为 i32，并初始化为 300 let ver1 = 400_i32; // 400后面加上 i32 类型后缀，自动推导 ver1 类型为 i32 static stvar: i32 = 8; // static声明静态变量 stvar，类型为 i32 未完待续","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"Rust","slug":"技术文章/Rust","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Rust/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"https://www.code64.cn/blog1/tags/Rust/"}]},{"title":"Linux 手动安装 Rust 最新版本编译器","slug":"Linux-手动安装-Rust-最新版本编译器","date":"2021-03-30T01:05:51.000Z","updated":"2022-02-24T14:35:47.194Z","comments":true,"path":"2021/03-30/8CDBAAFE38AE21B713FD085130F10844/","link":"","permalink":"https://www.code64.cn/blog1/2021/03-30/8CDBAAFE38AE21B713FD085130F10844/","excerpt":"","text":"Linux 手动安装 Rust 最新版本编译器 一般来说，Linux 发行版都自带了 Rust 编译器，通过 apt-get 或者 dnf 等包管理工具即可以安装 Rust 编译器。 Rust 编译器套件中包含了自升级命令行组件 rustup，可以进行升级操作： rustup self update # 升级 rustup 工具本身 rustup update # 升级 Rust 编译器整个套件 也可以去 Rust 官方去下载指定的版本进行手动安装。 手动安装可以选择安装组件，可以指定安装路径，也可以选择具体版本。 如下，去 “ 官方地址 ” 去下载具体版本; 这里选择以 1.51.0 版本为例子。（本文书写时最新版本为 1.51.0）。一般的 Linux 发行版的 platform 请选择 x86_64-unknown-linux-gnu， 特殊的 Alpine Linux发行版的 platform 请选择 x86_64-unknown-linux-musl 。 下面以下载到的文件 rust-1.51.0-x86_64-unknown-linux-gnu.tar.gz 为例： # 解压缩： tar zxvf rust-1.51.0-x86_64-unknown-linux-gnu.tar.gz # 进入解压缩后的目录: cd rust-1.51.0-x86_64-unknown-linux-gnu 查看一下具体目录结构： ls -l 你会看到，里面有个官方的安装脚本 install.sh ： ls -l total 68 -rwxrwxrwx 1 root root 9322 May 6 20:09 COPYRIGHT -rwxrwxrwx 1 root root 9723 May 6 20:09 LICENSE-APACHE -rwxrwxrwx 1 root root 1023 May 6 20:09 LICENSE-MIT -rwxrwxrwx 1 root root 9566 May 6 20:09 README.md drwxrwxrwx 1 root root 512 May 6 20:11 cargo drwxrwxrwx 1 root root 512 May 6 20:11 clippy-preview -rwxrwxrwx 1 root root 192 May 6 20:11 components -rwxrwxrwx 1 root root 40 May 6 20:10 git-commit-hash -rwxrwxrwx 1 root root 27856 May 6 20:10 install.sh drwxrwxrwx 1 root root 512 May 6 20:11 llvm-tools-preview drwxrwxrwx 1 root root 512 May 6 20:11 miri-preview drwxrwxrwx 1 root root 512 May 6 20:11 rls-preview drwxrwxrwx 1 root root 512 May 6 20:11 rust-analysis-x86_64-unknown-linux-gnu drwxrwxrwx 1 root root 512 May 6 20:11 rust-analyzer-preview drwxrwxrwx 1 root root 512 May 6 20:11 rust-docs -rwxrwxrwx 1 root root 2 May 6 20:11 rust-installer-version drwxrwxrwx 1 root root 512 May 6 20:11 rust-std-x86_64-unknown-linux-gnu drwxrwxrwx 1 root root 512 May 6 20:11 rustc drwxrwxrwx 1 root root 512 May 6 20:11 rustfmt-preview -rwxrwxrwx 1 root root 29 May 6 20:11 version 运行一下 install.sh 看看有什么安装选项： sudo ./install.sh --help Usage: ./install.sh [options] Options: --uninstall only uninstall from the installation prefix --destdir=[&lt;none&gt;] set installation root --prefix=[/usr/local] set installation prefix --without=[&lt;none&gt;] comma-separated list of components to not install --components=[&lt;none&gt;] comma-separated list of components to install --list-components list available components --sysconfdir=[/etc] install system configuration files --bindir=[/bin] install binaries --libdir=[/lib] install libraries --datadir=[/share] install data --mandir=[/share/man] install man pages in PATH --docdir=[\\&lt;default\\&gt;] install documentation in PATH --disable-ldconfig don&#39;t run ldconfig after installation (Linux only) --disable-verify don&#39;t obsolete --verbose run with verbose output 这里有几个有用的选项： --prefix=[/usr/local] 指定安装路径，不指定时为 /usr/local --list-components 列出可以安装的组件 --without=[&lt;none&gt;] 不安装指定组件 下面看看具体有哪些组件可供选择： sudo ./install.sh --list-components # Available components * rustc * cargo * rls-preview * rust-analyzer-preview * clippy-preview * miri-preview * rustfmt-preview * llvm-tools-preview * rust-analysis-x86_64-unknown-linux-gnu * rust-std-x86_64-unknown-linux-gnu * rust-docs 其中，本人亲测，rust-docs 为帮助文档，安装过程特别慢，而且文档可以直接在浏览器上网去查看，所以没有必要装到本地，采用以下命令进行安装： sudo ./install.sh --without=rust-docs 输入编译命令，测试一下，出现版本号则表示安装成功： rustc -V rustc 1.51.0 (2fd73fabe 2021-03-23)","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"Rust","slug":"技术文章/Rust","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Rust/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"https://www.code64.cn/blog1/tags/Rust/"}]},{"title":"C11 的变长数组","slug":"C11-的变长数组","date":"2020-07-03T03:20:13.000Z","updated":"2022-02-24T14:35:47.179Z","comments":true,"path":"2020/07-03/635C028687D671F50A1AF81E8F589D50/","link":"","permalink":"https://www.code64.cn/blog1/2020/07-03/635C028687D671F50A1AF81E8F589D50/","excerpt":"","text":"C11 的变长数组 C 语言新版本支持变长的数组（variable length array，简称VLA），数组的长度可以用一个变量来决定。 如果 C 编译器不支持变长数组，那么宏定义 __STDC_NO_VLA__ 就必须定义为 1。使用下面的代码可以检查是否支持变长数组： #ifdef __STDC_NO_VLA__ printf(&quot;不支持变长数组 \\n&quot;); #endif // __STDC_NO_VLA__ 代码中有些地方是不能声明和定义为变长数组的： 一、变长数组不能是全局变量二、extern 外部变量三、结构或者联合里面的字段四、static 变量 也就是说，变长数组只能用于非 static 的局部变量。 变长数组的实现原理是什么，下面以一个简单的 .c 程序，进行编译成汇编看看： // varr.c #include &lt;stdio.h&gt; static void func1(int arrsize) &#123; int array[arrsize]; // 这里定于可变数组，数组的大小由一个变量来决定 &#125; int main() &#123; func1(9); return 0; &#125; 用下面命令： gcc -std=c99 -S varr.c 编译为汇编得到： .file &quot;varr.c&quot; .text .def _func1; .scl 3; .type 32; .endef _func1: pushl %ebp movl %esp, %ebp pushl %ebx subl $20, %esp movl %esp, %eax movl %eax, %ecx movl 8(%ebp), %eax leal -1(%eax), %edx movl %edx, -12(%ebp) leal 0(,%eax,4), %edx movl $16, %eax subl $1, %eax addl %edx, %eax movl $16, %ebx movl $0, %edx divl %ebx imull $16, %eax, %eax call ___chkstk_ms subl %eax, %esp movl %esp, %eax addl $3, %eax shrl $2, %eax sall $2, %eax movl %eax, -16(%ebp) movl %ecx, %esp nop movl -4(%ebp), %ebx leave ret .def ___main; .scl 2; .type 32; .endef .globl _main .def _main; .scl 2; .type 32; .endef _main: pushl %ebp movl %esp, %ebp andl $-16, %esp subl $16, %esp call ___main movl $9, (%esp) call _func1 movl $0, %eax leave ret .ident &quot;GCC: (GNU) 10.2.0&quot; 从上述汇编代码中可以看出，可变数组是根据数组大小的变量，动态地在栈中开辟一串连续的空间，来作为动态数组的存储空间。函数执行完毕之后，这部分在栈内动态开辟的空间，会自动被回收。","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"C_CPP","slug":"技术文章/C-CPP","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/C-CPP/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://www.code64.cn/blog1/tags/C-C/"}]},{"title":"C# 直接引用命名空间中的静态成员","slug":"C-直接引用命名空间中的静态成员","date":"2018-12-02T01:29:59.000Z","updated":"2022-02-24T14:35:47.179Z","comments":true,"path":"2018/12-02/C2B887CEB1D1D3C9064A8AAB781E1659/","link":"","permalink":"https://www.code64.cn/blog1/2018/12-02/C2B887CEB1D1D3C9064A8AAB781E1659/","excerpt":"","text":"C#直接引用命名空间中的静态成员 C# 6.0 允许直接导入并调用类/命名空间中的静态成员，而不需要指定类名。 直接导入类/命名空间中的静态成员的语法为 (在 using 后面加上 static 来实现)： using static &lt;Namespace路径链&gt;.类型; 例如： using static System.Console; 这样就可以直接使用： using static System.Console; namespace Hello1 &#123; class Program &#123; static void Main(string[] args) &#123; WriteLine(&quot;我又开始作妖了.&quot;); // 等价于使用Console.WriteLine &#125; &#125; &#125; 命名空间也可以使用别名，格式如下： using 别名 = 命名空间或者类名; 当别名指向命名空间，则可以使用 “别名::类型” 的方式进行使用；如果别名指向类型名，则可以使用 “别名.成员” 进行访问。","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"CSharp","slug":"技术文章/CSharp","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/CSharp/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://www.code64.cn/blog1/tags/C/"}]},{"title":"React 中函数组件与类组件的样例","slug":"React-中函数组件与类组件的样例","date":"2018-10-09T08:46:52.000Z","updated":"2022-02-24T14:35:47.194Z","comments":true,"path":"2018/10-09/65F786835306E1C27B7023A6F17B5460/","link":"","permalink":"https://www.code64.cn/blog1/2018/10-09/65F786835306E1C27B7023A6F17B5460/","excerpt":"","text":"React中函数组件与类组件的样例 (1) 函数组件直接从函数里面返回结果，函数组件高效、直接、粗暴有力，没有this，没有实例初始化，没有状态state。 (2) 类组件则需要实例化，并有生命周期，有状态state。 下面就展示一下函数组件和类组件的样例： 首先html文件的head中包含以下script脚本： &lt;head&gt; &lt;script src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; 把JSX的文件，放在body里面引用： &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/babel&quot; src=&quot;example.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; 以下展示了React中函数组件与类组件的样例，example.js的内容： var app = document.getElementById(&quot;app&quot;); // 函数组件 function Comp1(props) &#123; return &lt;h2&gt;组件1，值为：&#123;props.value&#125;&lt;/h2&gt;; &#125; // 类组件 class Comp2 extends React.Component &#123; render() &#123; return &lt;h2&gt;组件2，值为： &#123;this.props.value&#125;. &lt;/h2&gt;; &#125; &#125; Comp2.defaultProps = &#123; value: &quot;组件2的值&quot; &#125; // function TestComp() &#123; return ( &lt;div id=&quot;id-for-test&quot;&gt; &lt;Comp1 value=&quot;组件1的值&quot; /&gt; &lt;Comp2 /&gt; &lt;/div&gt; ); &#125; const testComp = &lt;TestComp/&gt;; // const content = ( &lt;span&gt; &#123;testComp&#125; &lt;/span&gt; ); ReactDOM.render(content, app);","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"React","slug":"技术文章/React","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://www.code64.cn/blog1/tags/React/"}]},{"title":"C11 中具有安全边界检查的函数","slug":"C11-中具有安全边界检查的函数","date":"2018-07-05T15:13:05.000Z","updated":"2022-02-24T14:35:47.179Z","comments":true,"path":"2018/07-05/E42A88DCB6352F4DDF4EB86046878893/","link":"","permalink":"https://www.code64.cn/blog1/2018/07-05/E42A88DCB6352F4DDF4EB86046878893/","excerpt":"","text":"前言我记得最早加入安全边界检查函数的是微软，在一些涉及缓冲区的基本 C 函数中，一律加上了 _s 后缀的、具有安全边界检查功能的函数。有少部分与之前微软定义的不兼容，这里以 C11 标准为准。 C11 标准引入了这些函数，它们比之前习惯性使用的传统函数更加安全，可以防止出现缓冲区溢出问题错误的发生。但是，能不能做到真正安全，还是需要编码者更细心地正确去编码。 不可理喻的是，C11 标准居然把这些定义的标准设置为可选。既然是标准，就应该是必须实现的才对嘛。这个让使用者情何以堪，到底我们使用它还是不用它 ？？ 如何确定编译器是否支持安全边界检查函数如果编译器的标准库实现了安全边界检查函数，就会定义 __STDC_LIB_EXT1__ 的宏。 #include &lt;stdio.h&gt; int main() &#123; #ifdef __STDC_LIB_EXT1__ printf(&quot;已实现&quot;); #else printf(&quot;未实现&quot;); #endif // ifdef __STDC_LIB_EXT1__ &#125; 如何开启使用安全边界检查函数好奇葩的一点，如果你想使用安全边界检查函数，还要相应的在 #include 头文件之前定义一个宏 __STDC_WANT_LIB_EXT1__ 的值为 1，才能开启使用这个头文件中的安全边界检查函数。 举例，string.h 里面定义了一些安全边界检查函数，如果要使用它，就需要按照如下的写法： #define __STDC_WANT_LIB_EXT1__ 1 //把这个宏定义为 1 才开启安全边界检查函数 //#define __STDC_WANT_LIB_EXT1__ 0 //把这个宏定义为 0 会禁用安全边界检查函数 #include &lt;string.h&gt; strlen_sstrlen_s 是 strlen 的安全版本，用于返回字符串的长度。原型： size_t strnlen_s(const char *str, size_t strsz); 第一个参数 str 为字符串指针，第二个参数为缓冲区大小，如果字符串超出缓冲区大小还没有以 \\0 结尾则返回缓冲区大小。 strcpy_sstrcpy_s 是 strcpy 的安全版本，用于复制字符串。原型： errno_t strcpy_s(char *restrict dest, rsize_t destsz, const char *restrict src); 第二个参数指出目标缓冲区 dest 的大小。复制成功，返回 0；失败则返回非 0 。 strncpy_sstrncpy_s 是 strncpy 的安全版本，用于复制字符串。原型： errno_t strncpy_s(char *restrict dest, rsize_t destsz, const char *restrict src, rsize_t count); 第二个参数指出目标缓冲区 dest 的大小。第四个参数指出最多从 src 复制多少个字符。如果前 count 个字符中没有 \\0，会继续把 \\0 添加的目标字符串后面。复制成功，返回 0；失败则返回非 0 。 strcat_sstrcat_s 是 strcat 的安全版本，用于追加复制字符串。原型： errno_t strcat_s(char *restrict dest, rsize_t destsz, const char *restrict src); 第二个参数指出目标缓冲区 dest 的大小。 strncat_sstrncat_s 是 strncat 的安全版本，用于追加复制字符串。原型： errno_t strncat_s(char *restrict dest, rsize_t destsz, const char *restrict src, rsize_t count); 第二个参数指出目标缓冲区 dest 的大小。第四个参数指出最多从 src 追加复制多少个字符。如果前 count 个字符中没有 \\0，会继续把 \\0 添加的目标字符串后面。复制成功，返回 0；失败则返回非 0 。 gets_s从stdin流中读取字符串，直至接受到换行符或EOF时停止，并将读取的结果存放在 str 指针所指向的字符数组中。原型： char *gets_s( char *str, rsize_t n ); 第二个参数指出目标缓冲区 str 的大小。 strtok_s将字符串进行单元化，分割转换为一系列 token。（这个函数跟微软的不一样） char *strtok_s(char *restrict str, rsize_t *restrict strmax, const char *restrict delim, char **restrict ptr); str ： 需要被分割的字符串。执行第一次分割之后，对同一个字符串执行后续的分割时，这个参数是 NULL。 strmax ： 指向一个 rsize_t 的整数，这个整数表示需要分割的字符串的长度。每次调用 strtok_s 之后，函数会更新这个整数值，表示分割后剩余的字符数。 delim ： 包含所有可能分界的字符的字符串。 ptr ： 指向 char* 类型的变量的指针。函数在该变量中存储信息，允许在找到第一个 token 之后继续搜索标记。 返回值：返回分割的 token，如果没有，返回 NULL。","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"C_CPP","slug":"技术文章/C-CPP","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/C-CPP/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://www.code64.cn/blog1/tags/C-C/"}]},{"title":"C 语言中的常见的预定义宏","slug":"C-语言中的常见的预定义宏","date":"2018-07-04T02:30:43.000Z","updated":"2022-02-24T14:35:47.179Z","comments":true,"path":"2018/07-04/1A3A4A6F10A1D499E13A38054BF33B8F/","link":"","permalink":"https://www.code64.cn/blog1/2018/07-04/1A3A4A6F10A1D499E13A38054BF33B8F/","excerpt":"","text":"__DATA__此宏是编译器预定义的。表示当前的日期的一个字符串。 __FILE__此宏是编译器预定义的。表示当前的源文件名的一个字符串。 __LINE__此宏是编译器预定义的。表示当前的行号的的一个整数常量。 __TIME__此宏是编译器预定义的。表示当前的时间（精确到秒）的一个字符串。 __FUNCTION__此宏是编译器预定义的。表示当前函数的函数名。 __func__此宏是编译器预定义的。表示当前函数的函数名（ C99 标准才有 ）。 __STDC_VERSION__此宏是编译器预定义的。表示当前 C 语言标准的版本号的整数。 __cplusplus此宏是 C++ 特有的，表示当前 C++ 语言标准的版本号的整数。C 语言编译器下绝对不会定义此宏。此宏可以用来区分当前源文件是 C 还是 C++。 __STDC_UTF_16__如果该宏预定义为整数值1，则表示 char16_t 类型的值为 UTF-16 编码的字符。如果采用其他编码，则不会有此宏。 __STDC_UTF_32__如果该宏预定义为整数值1，则表示 char32_t 类型的值为 UTF-32 编码的字符。如果采用其他编码，则不会有此宏。 __STDC_LIB_EXT1__如果该宏被定义，则它是一个整数值 1，表示当前编译器实现了 C11 标准中安全版本的边界检查的函数集合，通常这些函数是以 _s 结尾的。否则该部分函数集合没有被实现。 __STDC_NO_VLA__如果该宏被定义，则它是一个整数值 1，表示该编译器不支持变长数组（ VLA ）。 __STDC_NO_ATOMICS__如果该宏被定义，则它是一个整数值 1，表示当前编译器不支持原子类型操作。（包括使用 _Atomic 限定符）如果没有定义此宏，不要 #include &lt;stdatomic.h&gt; __STDC_NO_COMPLEX__如果该宏被定义，则它是一个整数值 1，表示当前编译器不支持复数类型。如果没有定义此宏，不要 #include &lt;complex.h&gt; __STDC_NO_THREADS__如果该宏被定义，则它是一个整数值 1，表示当前编译器不支持 C 标准的线程库 （不是指 POSIX Thread），_Thread_local 关键字依然可以使用。如果没有定义此宏，不要 #include &lt;threads.h&gt; __GNUC__GCC 编译器才有此宏，表示 GCC 的版本号。但是 clang 为了兼容 GCC，也会定义此宏。 _MSC_VERVC 编译器才有此宏，表示 VC 的版本号。但是 Windows 下的 clang 为了兼容 VC，可能也会定义此宏。 __clang__clang 编译器才有此宏，表示 clang 的版本号。 __BORLANDC__Borland C/C++ 编译器才有此宏，表示 Borland C/C++ 的版本号。 _WIN32生成目标为 Windows 系统的程序，都会定义此宏，不管是 32 位还是 64 位的，都会。 _WIN64生成目标为 64位 Windows 系统的程序，会定义此宏，只有 64 位的 Windows，才会有定义此宏。 __APPLE__生成目标为苹果操作系统的程序，会定义此宏，不管是电脑还是手机、平板设备。 __unix__生成目标为 unix 及其兼容系统的程序。 __linux__生成目标为 linux 及其兼容系统的程序。","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"C_CPP","slug":"技术文章/C-CPP","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/C-CPP/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://www.code64.cn/blog1/tags/C-C/"}]},{"title":"Linux 安装 Objective-C 编译与运行环境","slug":"Linux-安装-Objective-C-编译与运行环境","date":"2018-05-02T06:21:31.000Z","updated":"2022-02-24T14:35:47.194Z","comments":true,"path":"2018/05-02/2597812BD6D3982B22AE70B954C5C5F1/","link":"","permalink":"https://www.code64.cn/blog1/2018/05-02/2597812BD6D3982B22AE70B954C5C5F1/","excerpt":"","text":"一般需要做 Objective-C 语言的开发和学习，都需要使用一套苹果电脑，可以是 MAC 台式机或者 MacBook，也可以在淘宝上面淘一台黑苹果，或者自己组装折腾一台黑苹果来用。 如果暂时还没有买 MAC 电脑，又打算感受一下 Objective-C 语言的骚，可以在Linux下搭建其编译和运行环境。下面以 Ubuntu 18.04 作为例子进行说明。Windows 10可以在 WSL 下运行整个 Ubuntu 18.04 达到同样效果。 首先更新apt： sudo apt-get update 更新已有软件包： sudo apt-get upgrade 安装 gcc，因为 Objective-C 依赖于 gcc ： # 安装 gcc 的 C 和 C++ 编译器 sudo apt-get install gcc sudo apt-get install g++ 安装 gcc 中的 Objective-C 编译器： sudo apt-get install gobjc 安装 GNUstep 运行环境： sudo apt-get install gnustep 安装 GNUstep 开发库： sudo apt-get install gnustep-devel 安装 GNUstep 的 Makefile 依赖： sudo apt-get install gnustep-make 编辑并保存以下 Objective-C 的 Hello World 样例，文件名为 hello1.m #import &lt;Foundation/Foundation.h&gt; int main(void) &#123; NSLog(@&quot;Hello, world!&quot;); return (0); &#125; 执行以下命令进行编译： gcc `gnustep-config --objc-flags` -o hello1 hello1.m 报错了，信息如下： hello1.m: In function ‘main’: /tmp/ccuU7quf.o: In function `main&#39;: /mnt/c/test/objc/hello1.m:5: undefined reference to `NSLog&#39; /tmp/ccuU7quf.o: In function `__objc_gnu_init&#39;: /mnt/c/test/objc/hello1.m:6: undefined reference to `__objc_exec_class&#39; /tmp/ccuU7quf.o:(.data.rel+0x0): undefined reference to `__objc_class_name_NSConstantString&#39; collect2: error: ld returned 1 exit status 这是因为没有连接上 libobjc 库和 libgnustep-base 库导致，把编译命令更改为： gcc `gnustep-config --objc-flags` -o hello1 hello1.m \\ /usr/lib/x86_64-linux-gnu/libobjc.so.4 /usr/lib/libgnustep-base.so 编译通过啦，可以直接运行： ./hello1 # 这里省去了很多初始化的LOG 2020-07-25 16:53:58.830 hello1[6624:6624] Hello, world!","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"Objective-C","slug":"技术文章/Objective-C","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Objective-C/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://www.code64.cn/blog1/tags/Objective-C/"}]},{"title":"Swift 中的可空类型","slug":"Swift-中的可空类型","date":"2017-08-24T11:12:05.000Z","updated":"2022-02-24T14:35:47.194Z","comments":true,"path":"2017/08-24/52847D92261A0D1FEE1A3F3F4911B4DF/","link":"","permalink":"https://www.code64.cn/blog1/2017/08-24/52847D92261A0D1FEE1A3F3F4911B4DF/","excerpt":"","text":"Swift中的可空类型 印象中，C#语言很早就引入了可空类型。Swift语言也存在可空类型（也叫可选类型）。可空类型有个特有的特性，可空类型的变量，（1）要么有值 （2）要么为空（nil）。 声明可空类型，就是在类型名后面加一个“?”号。例如： var opValue1 : String? var opValue2 : String? = &quot;abc&quot; // 声明字符串可空类型,并初始化 可空类型是对普通类型的一种包装。如果需要取可空类型变量的值，就需要对可空类型进行拆包操作。拆包使用拆包操作符“!”，在变量的后面加上感叹号，就可以进行拆包，取得可空类型的具体数据，例如： import Foundation var opValue: String? = &quot;superMe&quot; // 声明字符串可空类型,并初始化 print(opValue!) // 使用!拆开取得可空类型的数据 以上拆包的操作必须保证可空变量的值有效，如果可空变量为nil，则拆包会导致程序运行错误，拆包之前需要先判断可空变量是否为nil。 if opValue != nil &#123; opValue! &#125; 这里建议不要对可空变量进行拆包，而建议采用第二种拆包取值方法，叫实例绑定。它是一种 if-let/if-var 语法结构，如下： import Foundation var opValue: Int32? = 1024 // 声明整数可空类型,并初始化 if let tmp = opValue &#123; // if-let 语句对可空变量进行实例绑定， // 绑定成功则返回true，为nil则返回false print(tmp) &#125; else &#123; print(&quot;opValue为nil&quot;); &#125; 可以一次性给多个可空变量进行实例绑定，如下所示： import Foundation var opValue1: Int64? = 1024 var opValue2: Int64? = 2048 if let tmp1 = opValue1, let tmp2 = opValue2 &#123; // 只有所有实例绑定都成功才返回true print(tmp1) print(tmp2) &#125; else &#123; print(&quot;opValue1或者opValue2为nil&quot;); &#125;","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"Swift","slug":"技术文章/Swift","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://www.code64.cn/blog1/tags/Swift/"}]},{"title":"Swift 变量的声明","slug":"Swift-变量的声明","date":"2017-08-23T04:11:35.000Z","updated":"2022-02-24T14:35:47.194Z","comments":true,"path":"2017/08-23/16D7BAE2FFFFDAC1F7D05A7992000912/","link":"","permalink":"https://www.code64.cn/blog1/2017/08-23/16D7BAE2FFFFDAC1F7D05A7992000912/","excerpt":"","text":"Swift变量的声明 这里的变量泛指通常意义上的变量和常量，因为可以把常量理解为不可变的变量。Swift变量的声明使用 var 关键字，常量使用 let 关键字，举例： import Foundation var value1 = &quot;Hello World 1&quot; // 声明变量value1，并初始化，编译器自动推导为字符串类型 let value2 = &quot;Hello World 2&quot; // 声明常量value2，并初始化，编译器自动推导为字符串类型 var value3 = 3 // 声明变量value3，并初始化，编译器自动推导为Int整数类型 var value4 = 1.1 // 声明变量value4，并初始化，编译器自动推导为Double浮点数类型 var 中文变量名 = 400 // 可以使用Unicode字符作为变量名 print(value1) print(value2) print(value3) print(value4) print(中文变量名) Swift是强类型的语言，编译器会根据变量初始化的值，自动推导出变量的类型。赋值语句与类型不匹配会导致编译出错。例如下面代码，将会编译出错： var value1 = &quot;abc&quot; let value2 = &quot;xyz&quot; value1 = 100 // 编译出错，因为value1的类型在上面已经推导为String value2 = &quot;ijk&quot; // 编译出错，value2为常量，不能改变其值 以下是在声明变量的时候，显式地指明了变量的类型：（采用变量名后面加冒号“:” 再加上类型名） import Foundation var var1:Int = 3 // 声明整数 var var2:Float = 1.2 // 声明浮点数(32位) var var3:Double = 1.6 // 声明浮点数(64位) var var4:String = &quot;abc&quot; // 声明字符串 var var5:Bool = true // 声明布尔类型 let const1:Int8 = 1 // 声明8位有符号整数 let const2:UInt8 = 4 // 声明8位无符号整数 let const3:Int16 = 7 // 声明16位有符号整数 let const4:UInt16 = 2 // 声明16位无符号整数 let const5:Int32 = 5 // 声明32位有符号整数 let const6:UInt32 = 8 // 声明32位无符号整数 let const7:Int64 = 3 // 声明64位有符号整数 let const8:UInt64 = 6 // 声明64位无符号整数","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"Swift","slug":"技术文章/Swift","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://www.code64.cn/blog1/tags/Swift/"}]},{"title":"JavaScript 的数组排序","slug":"JavaScript-的数组排序","date":"2015-04-22T04:21:15.000Z","updated":"2022-02-24T14:35:47.194Z","comments":true,"path":"2015/04-22/31B99BD6F0F6FE2D5C177FA136D6EE15/","link":"","permalink":"https://www.code64.cn/blog1/2015/04-22/31B99BD6F0F6FE2D5C177FA136D6EE15/","excerpt":"","text":"JavaScript的数组中，提供了一个相当实用的方法，用于数组的排序。 这个方法就是 sort()。调用 sort() 方法之后，数组会根据每一项从小到大排列，看看下面例子： var arr = [1, 2, 3, 4, 5, 9, 8, 7, 6]; arr.sort(); console.log(arr); 得到的结果如下： [1, 2, 3, 4, 5, 6, 7, 8, 9] 再看看一个例子： var arr = [10086, 10010, 28, 56, 3, 31]; arr.sort(); console.log(arr); 得到的结果如下： [10010, 10086, 28, 3, 31, 56] 上面的结果并没有按照数值的大小，从小到大排列。而是把所有的数字值先转换为字符串，再以字符串进行比较所得到的排序结果。如果需要以数值进行排序，则 sort 方法需要一个传入一个比较函数作为参数，来控制数组的排序方向，例如： function compareNumber(a, b) &#123; return a - b; &#125; var arr = [10086, 10010, 28, 56, 3, 31]; arr.sort(compareNumber); console.log(arr); 得到的结果如下： [3, 28, 31, 56, 10010, 10086] 加入了比较函数compareNumber来控制数组的排序之后，可以看到排序结果按照意想中的按数值从小到达进行排列。 如果需要按照数值的大小，从大到小排列呢。以下说明以下比较函数的控制规则： function compareNumber(a, b) &#123; //return -1; //return 0; //return 1; &#125; (1) 如果a应该排在b的前面，返回负数 (2) 如果a应该排在b的后面，返回正数 (3) 如果a与b相等，返回0","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"JavaScript","slug":"技术文章/JavaScript","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.code64.cn/blog1/tags/JavaScript/"}]},{"title":"Java 的反射与注解","slug":"Java-的反射与注解","date":"2011-08-21T02:43:12.000Z","updated":"2022-02-24T14:35:47.194Z","comments":true,"path":"2011/08-21/C3A70A5614ED50A3FB175C56BEA4464C/","link":"","permalink":"https://www.code64.cn/blog1/2011/08-21/C3A70A5614ED50A3FB175C56BEA4464C/","excerpt":"","text":"反射反射机制与 Class 类反射机制是程序在运行的中途，动态地获取一个类或者对象的成员与方法，并使用它们的机制。反射是通过 java.lang.Class 类的方法来实现。 Java 中每个对象都是 Class 类的一个对象，可以通过下面方式获取到 Class 对象： 通过调用对象的 getClass() 方法获得： Class classObj = objectName.getClass(); 通过类的隐含静态对象成员变量 class 获得： Class classObj = ClassName.class; 通过 Class 类的静态方法 forName() 去查找获得。这里必须加上异常处理，因为有可能找不到对应的类。 try &#123; Class classObj = Class.forName(&quot;com.xxxx.xxxx.ClassName&quot;); &#125; catch(ClassNotFoundException e) &#123; e.printStackTrace(); &#125; 获取构造方法使用 Class 类对象的下面成员方法获取类的构造方法： 方法 返回值 说明 getConstructors() Constructor对象数组 返回类的所有public的构造方法 getDeclaredConstructors() Constructor对象数组 返回类的所有构造方法，按声明顺序返回 getConstructor(Class&lt;?&gt;... paramTypes) Constructor对象 返回类的一个public的指定构造方法 getDeclaredConstructor(Class&lt;?&gt;... paramTypes) Constructor对象 返回类的一个指定构造方法 举例： class ClassName1 &#123; public ClassName1(String value1, int value2) &#123; &#125; &#125; //---- public class Test1 &#123; public Test1() &#123;&#125; Class cls = ClassName1.class; constructor = cls.getConstructor(String.class, int.class); &#125; Constructor 类中的常用方法： 方法 说明 newInstance() 调用构造器创建一个该类的新实例对象 isVarArgs() 该构造方法是否可以带可变数量的参数，是则返回 true，否则返回 false getParameterTypes() 返回 Class 对象数组，表示该构造方法的参数类型 getExceptionTypes() 返回 Class 对象数组，表示该构造方法可能抛出的异常类型 setAccessible(boolean) 设置为 true 则可以调用非 public 的构造方法来创建对象 getModifiers() 返回一个整数，表示该构造方法的修饰符 修饰符的解释getModifiers() 方法会返回一个整数代表的修饰符，用Modifier类的下面静态方法可以解释修饰符： 方法 说明 isPublic(int) 是否 public 修饰 isProtected(int) 是否 protected 修饰 isPrivate(int) 是否 private 修饰 isStatic(int) 是否 static 修饰 isFinal(int) 是否 final 修饰 toString(int) 将所有修饰与字符串的形式返回 获取和访问成员变量通过 Class 类对象的下面方法获取成员变量的变量信息： 方法 说明 getField(String) 返回一个 Field 对象，代表一个 public 的成员 getFields() 返回一个 Field 对象数组，代表所有 public 的成员列表(包括父类的成员) getDeclaredField(String) 返回一个 Field 对象，代表一个的成员 getDeclaredFields() 返回一个 Field 对象数组，代表所有的成员列表(不包括继承的成员) Field 类常用的方法有： 方法 说明 get(Object obj) 返回此 Field 表示的成员对象 set(Object obj, Object value) 将此 Field 表示的成员对象设置为指定值 getName() 获取字段的名称 getType() 返回一个 Class 对象，获取字段的类型 getInt(Object obj) 获取 int 类型的 obj 的成员变量的值 setInt(Object obj, int value) 设置 int 类型的 obj 的成员变量的值 getFloat(Object obj) 获取 float 类型的 obj 的成员变量的值 setFloat(Object obj, float value) 设置 float 类型的 obj 的成员变量的值 getBoolean(Object obj) 获取 boolean 类型的 obj 的成员变量的值 setBoolean(Object obj, boolean value) 设置 boolean 类型的 obj 的成员变量的值 setAccessible(boolean) 设置为 true 则可以访问非 public 的成员 getModifiers() 返回一个整数，表示该成员的修饰符 获取和访问方法通过 Class 类对象的下面方法获取方法信息： 方法 说明 getMethod(String name, Class&lt;?&gt;... paramTypes) 返回一个 Method 对象，代表一个 public 的方法 getMethods() 返回一个 Method 对象数组，代表所有 public 的方法 getDeclaredMethod(String name, Class&lt;?&gt;... paramTypes) 返回一个 Method 对象，代表一个方法 getDeclaredMethods() 返回一个 Method 对象数组，代表所有的方法(不包括继承的方法) Method 类常用的方法有： 方法 说明 invoke(Object obj, Object... args) 调用 obj 对象的方法 getName() 获取方法名 getReturnType() 返回一个 Class 对象，获取方法的返回值类型 getParameterTypes() 返回 Class 对象数组，获取方法的参数列表的类型的数组 getExceptionTypes() 返回 Class 对象数组，获取方法的可能抛出的类型的数组 isVarArgs() 该方法是否可以带可变数量的参数，是则返回 true，否则返回 false getModifiers() 返回一个整数，表示该方法的修饰符 注解 （Annotation）注解是以结构化的方式为程序提供额外信息，包括能被编译器、加载器、解释器等自动处理的额外信息。可以进行注解的有： 包 类型（类、接口、枚举） 构造方法 方法 成员变量 参数 局部变量 注解类型 是指一种特殊的接口类型，注解 则是指 注解类型 的一个实例。 注解中的信息是以 键 / 值 对的形式存在的，可以存在 0 个或者多个键值对。没有键值对的注解叫标记注解类型。 标准注解Java 在 API java.lang 包中定义了三个标准的内置注解。如下： 1. @Override@Override 是一个标记注解类型，用于编译器检查该方法是否是重载方法，可以方式程序员在重写覆盖某个方法时犯错。如果要重写的方法不是父类的方法，则编译器会报错。 2. @Deprecated@Deprecated 是一个标记注解类型，表示该字段以后版本可能会被废弃，请使用者不应该继续使用，请采用其他方法代替。编译时会有警告提示。但是目前版本还是被使用。 3. @SuppressWarnings@SuppressWarnings 注解是请编译器不要提示某些类型的警告信息出现。它的用法是传递一个字符串数组作为参数。例如： @SuppressWarnings(value=(&quot;deprecation&quot;, &quot;unchecked&quot;, &quot;unused&quot;)) public void func1(void) &#123;&#125; 元注解元注解 是对注解进行注解的注解。在 API java.lang.annotation 包中定义了四个标准的元注解。 1. @Documented@Documented 是一个标记注解类型，被它注解的元素应该被 javadoc 文档化。 2. @Inherited默认标记在父类上面的注解是不会被子类继承的。@Inherited 表示注解类型会被子类继承。 3. @Retension表示注解的有效期，也就是注解的保留时间。它的值是一个 java.lang.annotation.RetensionPolicy 的枚举值。该枚举有下面值，表示下面不同的含义： 值 说明 SOURCE 注解只存在与源文件，编译器解释该注解之后就会丢弃 CLASS 注解会留存在*.class文件中，但是 JVM 不会去读取此注解。默认值 RUNTIME 注解会被 JVM 加载。可以使用反射机制来查询到该注解的内容 4. @Target用于指明注解修饰的对象范围，也就是指明适用的元素类型。如果未设置 @Target，则表示所有程序元素都适用。 它的值是一个 java.lang.annotation.ElementType 的枚举值。该枚举有下面值，表示下面不同的含义： 值 说明 PACKAGE 注解只标注包 TYPE 注解只标注类、接口、枚举以及 Annotation 类型 ANNOTATION_TYPE 注解只标注 Annotation 类型 CONSTRUCTOR 注解只标注构造方法 FIELD 注解只标注成员 METHOD 注解只标注方法 PARAMETER 注解只标注参数 LOCAL_VARIABLE 注解只标注局部变量 自定义注解自定义注解使用 interface 关键字前面加一个 “@” 来实现，自定义注解隐含继承了 java.lang.annotation.Annotation 接口。有些地方需要注意的是： 注解中的方法不需要加上 private、protected、public 等修饰，保持默认即可 注解中的方法可以加上 default 来声明默认值 自定义注解不能继承其他注解或者接口 可以加上元注解来描述注解的使用方式与范围 举例： package com.testanno; import java.lang.annotation.*; @Target(value = &#123;ElementType.TYPE, ElementType.METHOD&#125;) @Retention(RetentionPolicy.RUNTIME) @Inherited @Documented public @interface Anno1 &#123; // 这里声明一个注解类型叫 Anno1 int value1() default 1; String value2() default &quot;string-1&quot;; Class type() default int.class; &#125; 通过反射机制访问注解信息Constructor、Field、Method 类都是继承于 AccessibleObject 类，提供了一下相关的方法： isAnnotationPresent : 用于查询是否附加了指定类型的注解 getAnnotation : 获取指定类型的注解对象 getAnnotations : 获取所有的注解对象，返回一个注解对象数组 getParameterAnnotations : 获取所有参数所添加的注解对象，返回一个二维注解对象数组 使用注解例子： package com.testanno; public class Test1 &#123; // 直接使用上一个例子中的 Anno1 注解类型 @Anno1(value1 = 100, value2 = &quot;string-2&quot;) public void function1()&#123; System.out.println(&quot;function1&quot;); &#125; @Anno1 public void function2() &#123; System.out.println(&quot;function2&quot;); &#125; &#125; 下面例子是通过反射机制来访问注解信息： package com.testanno; import java.lang.reflect.Method; public class MyTest &#123; public static void main(String[] args) &#123; try &#123; Class cls = Class.forName(&quot;com.testanno.Test1&quot;); // 通过反射获得类对象 Method[] methods = cls.getMethods(); // 获得所有方法 for (Method curMethod: methods) &#123; // 遍历所有方法 if (curMethod.isAnnotationPresent(Anno1.class)) &#123; Anno1 anno1 = curMethod.getAnnotation(Anno1.class); // 获得方法的注解 System.out.println(&quot;Method name = &quot; + curMethod.getName()); System.out.println(&quot;value1 = &quot; + anno1.value1() + &quot;, value2 = &quot; + anno1.value2() + &quot;\\n&quot;); &#125; &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 输出结果： Method name = function2 value1 = 1, value2 = string-1 Method name = function1 value1 = 100, value2 = string-2","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"Java","slug":"技术文章/Java","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.code64.cn/blog1/tags/Java/"}]},{"title":"AT&T 汇编伪指令说明","slug":"AT-T-汇编伪指令说明","date":"2009-10-08T01:32:15.000Z","updated":"2022-02-24T14:35:47.179Z","comments":true,"path":"2009/10-08/BF629617CAE2B0FF08CB38DCE94AA184/","link":"","permalink":"https://www.code64.cn/blog1/2009/10-08/BF629617CAE2B0FF08CB38DCE94AA184/","excerpt":"","text":"AT&amp;T 汇编伪指令说明.globl 或者 .global.globl / .global 伪指令将符号定义为全局可链接的，跨文件可以访问的符号。 .globl label_name .extern.extern 定义外部符号 .extern label_name .comm 和 .lcomm.comm 定义 COMM （未初始化变量）类型的全局符号； .lcomm 定义 COMM （未初始化变量）类型的局部符号 #.comm/.lcomm 符号名, 大小 .comm label_name, 8 .lcomm label_name, 16 .weak.weak 伪指令将符号定义为弱类型，其他同名符号存在是，应该优先采用其他强类型的符号。 .weak label_name .hidden.hidden 伪指令将符号定义为隐藏属性。该符号为全局符号，但是对于 elf 文件来说，不暴露处理。加上此属性的符号，在生成的 .so 文件中，其他模块是找不到该符号的。 .hidden label_name .type.type 伪指令指明符号的类型，可以取值：object 或者 function。object 表示数据，function 表示函数。 .type var1, @object .type function_1, @function .size.size 伪指令指明符号的占用空间的大小 .size var1, 4 .align.align 指出紧跟的数据或者代码要求的对齐值。 .align 4 .zero填充多少个0 .zero 4 .rept 和 .endr用来重复汇编语句块，例子： .rept 3 .long 100 .endr # 相当于如下重复了 3 次 .long 100 .long 100 .long 100 .space填充产生多个重复字节的值： # .space size, fill .space 100, 2 # 100 个 2 .space 200 # 200 个 0，不指定值则默认为 0","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"x86汇编","slug":"技术文章/x86汇编","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/x86%E6%B1%87%E7%BC%96/"}],"tags":[{"name":"x86汇编","slug":"x86汇编","permalink":"https://www.code64.cn/blog1/tags/x86%E6%B1%87%E7%BC%96/"}]},{"title":"x86 扩展传送指令","slug":"x86-扩展传送指令","date":"2008-09-02T00:40:25.000Z","updated":"2022-02-24T14:35:47.194Z","comments":true,"path":"2008/09-02/FC725941C3976746BC698D7630894FFA/","link":"","permalink":"https://www.code64.cn/blog1/2008/09-02/FC725941C3976746BC698D7630894FFA/","excerpt":"","text":"x86 扩展传送指令x86 扩展传送指令包含了两种指令1. 符号扩展传送指令 MOVSX把寄存器或者内存的值，符号扩展到更大的寄存器中。 有如下操作数匹配方式： MOVSX reg16, reg8/mem8 MOVSX reg32, reg8/mem8 MOVSX reg64, reg8/mem8 MOVSX reg32, reg16/mem16 MOVSX reg64, reg16/mem16 MOVSXD reg64, reg32/mem32 2. 零扩展传送指令 MOVZX把寄存器或者内存的值，零扩展到更大的寄存器中。 有如下操作数匹配方式： MOVZX reg16, reg8/mem8 MOVZX reg32, reg8/mem8 MOVZX reg64, reg8/mem8 MOVZX reg32, reg16/mem16 MOVZX reg64, reg16/mem16 AT&amp;T 格式的扩展传送指令 传送方向改为从左至右 指令后面加上 B、W 指明操作数大小 MOVSXD 也可以用 MOVSXL 来代替 movsxb reg8/mem8, reg16 movsxb reg8/mem8, reg32 movsxb reg8/mem8, reg64 movsxw reg16/mem16, reg32 movsxw reg16/mem16, reg64 movsxd reg32/mem32, reg64 movsxl reg32/mem32, reg64 movzxb reg8/mem8, reg16 movzxb reg8/mem8, reg32 movzxb reg8/mem8, reg64 movzxw reg16/mem16, reg32 movzxw reg16/mem16, reg64","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"x86汇编","slug":"技术文章/x86汇编","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/x86%E6%B1%87%E7%BC%96/"}],"tags":[{"name":"x86汇编","slug":"x86汇编","permalink":"https://www.code64.cn/blog1/tags/x86%E6%B1%87%E7%BC%96/"}]},{"title":"x86 串操作指令","slug":"x86-串操作指令","date":"2008-07-29T16:10:05.000Z","updated":"2022-02-24T14:35:47.194Z","comments":true,"path":"2008/07-30/8C2D0EB461D3748AFBC2011CEA105279/","link":"","permalink":"https://www.code64.cn/blog1/2008/07-30/8C2D0EB461D3748AFBC2011CEA105279/","excerpt":"","text":"方向标志位 DF方向标志位 DF 是 EFLAGS 寄存器中的 bit-10，用于指明串操作的方向。 SI/ESI/RSI 寄存器中的 S 代表 “源” （只配合 DS 段使用） DI/EDI/RDI 寄存器中的 D 代表 “目标”（只配合 ES 段使用） DF 为 0 时，每次操作之后，SI/ESI/RSI、DI/EDI/RDI 寄存器递增 DF 为 0 时，每次操作之后，SI/ESI/RSI、DI/EDI/RDI 寄存器递减 CLD 指令： 该指令将 DF 清 0 STD 指令： 该指令将 DF 置 1 串传送指令1. MOVSB 将 SI/ESI/RSI 指定的源内存地址中 1 个字节的数据，传送到 DI/EDI/RDI 指定的目标内存地址中。 并且，SI/ESI/RSI 和 DI/EDI/RDI 根据 DF 标志自动递增或者递减 1。 2. MOVSW 将 SI/ESI/RSI 指定的源内存地址中 2 个字节的数据，传送到 DI/EDI/RDI 指定的目标内存地址中。 并且，SI/ESI/RSI 和 DI/EDI/RDI 根据 DF 标志自动递增或者递减 2。 3. MOVSL （AT&amp;T语法） MOVSD （Intel语法） 将 SI/ESI/RSI 指定的源内存地址中 4 个字节的数据，传送到 DI/EDI/RDI 指定的目标内存地址中。 并且，SI/ESI/RSI 和 DI/EDI/RDI 根据 DF 标志自动递增或者递减 4。 4. MOVSQ 将 SI/ESI/RSI 指定的源内存地址中 8 个字节的数据，传送到 DI/EDI/RDI 指定的目标内存地址中。 并且，SI/ESI/RSI 和 DI/EDI/RDI 根据 DF 标志自动递增或者递减 8。 REP 前缀串操作指令一般是配合 rep 前缀使用。 rep 前缀的作用是根据 CX/ECX/RCX 寄存器的值，重复执行多次串指令，每执行一次， CX/ECX/RCX 自动减 1。 rep movsw 相当于如下指令： L1: movsw loop L1 串加载指令1. LODSB 将 SI/ESI/RSI 指定的源内存地址中 1 个字节的数据，传送到 AL 寄存器中。 并且，SI/ESI/RSI 根据 DF 标志自动递增或者递减 1。 2. LODSW 将 SI/ESI/RSI 指定的源内存地址中 2 个字节的数据，传送到 AX 寄存器中。 并且，SI/ESI/RSI 根据 DF 标志自动递增或者递减 2。 3. LODSL （AT&amp;T语法） LODSD （Intel语法） 将 SI/ESI/RSI 指定的源内存地址中 4 个字节的数据，传送到 EAX 寄存器中。 并且，SI/ESI/RSI 根据 DF 标志自动递增或者递减 4。 4. LODSQ 将 SI/ESI/RSI 指定的源内存地址中 8 个字节的数据，传送到 RAX 寄存器中。 并且，SI/ESI/RSI 根据 DF 标志自动递增或者递减 8。 串存储指令1. STOSB 将 AL 寄存器的值（1 个字节）存储到 DI/EDI/RDI 指定的目标内存地址中。 并且，DI/EDI/RDI 根据 DF 标志自动递增或者递减 1。 2. STOSW 将 AX 寄存器的值（2 个字节）存储到 DI/EDI/RDI 指定的目标内存地址中。 并且，DI/EDI/RDI 根据 DF 标志自动递增或者递减 2。 3. STOSL （AT&amp;T语法） STOSD （Intel语法） 将 EAX 寄存器的值（4 个字节）存储到 DI/EDI/RDI 指定的目标内存地址中。 并且，DI/EDI/RDI 根据 DF 标志自动递增或者递减 4。 4. STOSQ 将 RAX 寄存器的值（8 个字节）存储到 DI/EDI/RDI 指定的目标内存地址中。 并且，DI/EDI/RDI 根据 DF 标志自动递增或者递减 8。 STOSB/STOSW/STOSL/STOSQ 可以配合 rep 前缀对大内存缓冲区进行初始化。 串比较指令1. CMPSB SI/ESI/RSI 指定的源内存地址，DI/EDI/RDI 指定的目标内存，1 字节减操作，源减去目标，然后根据结果设置 EFLAGS 寄存器标志。 并且，SI/ESI/RSI 和 DI/EDI/RDI 根据 DF 标志自动递增或者递减 1。 2. CMPSW SI/ESI/RSI 指定的源内存地址，DI/EDI/RDI 指定的目标内存，2 字节减操作，源减去目标，然后根据结果设置 EFLAGS 寄存器标志。 并且，SI/ESI/RSI 和 DI/EDI/RDI 根据 DF 标志自动递增或者递减 2。 3. CMPSL （AT&amp;T语法） CMPSD （Intel语法） SI/ESI/RSI 指定的源内存地址，DI/EDI/RDI 指定的目标内存，4 字节减操作，源减去目标，然后根据结果设置 EFLAGS 寄存器标志。 并且，SI/ESI/RSI 和 DI/EDI/RDI 根据 DF 标志自动递增或者递减 4。 4. CMPSQ SI/ESI/RSI 指定的源内存地址，DI/EDI/RDI 指定的目标内存，8 字节减操作，源减去目标，然后根据结果设置 EFLAGS 寄存器标志。 并且，SI/ESI/RSI 和 DI/EDI/RDI 根据 DF 标志自动递增或者递减 8。 CMPSB/CMPSW/CMPSL/CMPSQ 可以配合 REP、REPE、REPNE、REPZ、REPNZ前缀一起使用来实现各种字符串比较操作。 串扫描指令1. SCASB AL 作为源操作数，DI/EDI/RDI 指定的目标内存，1 字节减操作，源减去目标，然后根据结果设置 EFLAGS 寄存器标志。 并且，DI/EDI/RDI 根据 DF 标志自动递增或者递减 1。 2. SCASW AX 作为源操作数，DI/EDI/RDI 指定的目标内存，2 字节减操作，源减去目标，然后根据结果设置 EFLAGS 寄存器标志。 并且，DI/EDI/RDI 根据 DF 标志自动递增或者递减 1。 3. SCASL （AT&amp;T语法） SCASD （Intel语法） EAX 作为源操作数，DI/EDI/RDI 指定的目标内存，4 字节减操作，源减去目标，然后根据结果设置 EFLAGS 寄存器标志。 并且，DI/EDI/RDI 根据 DF 标志自动递增或者递减 1。 4. SCASQ RAX 作为源操作数，DI/EDI/RDI 指定的目标内存，8 字节减操作，源减去目标，然后根据结果设置 EFLAGS 寄存器标志。 并且，DI/EDI/RDI 根据 DF 标志自动递增或者递减 1。 SCASB/SCASW/SCASL/SCASQ 可以配合 REP、REPE、REPNE、REPZ、REPNZ前缀一起使用来实现各种字符串比较、查找操作。","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"x86汇编","slug":"技术文章/x86汇编","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/x86%E6%B1%87%E7%BC%96/"}],"tags":[{"name":"x86汇编","slug":"x86汇编","permalink":"https://www.code64.cn/blog1/tags/x86%E6%B1%87%E7%BC%96/"}]},{"title":"x86 条件分支指令说明","slug":"x86-条件分支指令说明","date":"2008-06-02T04:30:15.000Z","updated":"2022-02-24T14:35:47.194Z","comments":true,"path":"2008/06-02/B0EA0DDDACFBB69B427241B45BF11C50/","link":"","permalink":"https://www.code64.cn/blog1/2008/06-02/B0EA0DDDACFBB69B427241B45BF11C50/","excerpt":"","text":"EFLAGSx86 处理器的 EFLAGS 寄存器有很多位，但是与条件分支相关的是其中的 5 位： ZF bit6，零标志位。执行指令之后，其结果为 0 时，该标志位置 1，不为 0 时置 0。 SF bit7，符号标志位。执行指令之后，其结果为负数时，该标志位置 1，否则置 0。 CF bit0，进位标志位。执行指令之后，发生向超出最高位进位，或者从超出最高位借位时，该标志位置 1，否则置 0。 OF bit11，溢出标志位。执行指令之后，超出机器能表示的范围时，该标志位置 1，否则置 0。 PF bit2，奇偶标志位。执行指令之后，结果中的所有位中，1 的个数位偶数时，该标志位置 1，否则置 0。 CLC 指令： 该指令将 CF 清 0 STC 指令： 该指令将 CF 置 1 CLC 指令： 该指令将 CF 取反 条件跳转指令列表 对于使用无符号数的比较，则使用 above （A）和 below （B）关键字比较; 对于使用有符号数的比较，则使用 greater （G）和 less （L）关键字进行比较。 序 号 指 令 描 述 EFLAGS 1 JO 如果溢出（overflow），则跳转 OF == 1 2 JNO 如果没溢出（not overflow），则跳转 OF == 0 3 JB 如果小于（below），则跳转 CF == 1 4 JC 如果 CF == 1，则跳转 CF == 1 5 JNAE 如果不大于（not above）或者等于 CF == 1 6 JNB 如果不小于（not below） CF == 0 7 JNC 如果 CF != 1，则跳转 CF == 0 8 JAE 如果大于（above）或等于，则跳转 CF == 0 9 JZ 如果 ZF == 1，则跳转 ZF == 1 10 JE 如果相等（equal），则跳转 ZF == 1 11 JNZ 如果 ZF != 1，则跳转 ZF == 0 12 JNE 如果不相等（not equal），则跳转 ZF == 0 13 JBE 如果小于（below）或等于，则跳转 CF == 1 && ZF == 1 14 JNA 如果不大于（not above），则跳转 CF == 1 && ZF == 1 15 JNBE 如果不小于（not below）或等于，则跳转 CF == 0 && ZF == 0 16 JA 如果大于（above），则跳转 CF == 0 && ZF == 0 17 JS 如果 SF == 1，则跳转 SF == 1 18 JNS 如果 SF == 0，则跳转 SF == 0 19 JP 如果奇偶检验（parity），则跳转 PF == 1 20 JPE 如果偶检验（parity even），则跳转 PF == 1 21 JNP 如果不奇偶检验（not parity），则跳转 PF == 0 22 JPO 如果奇检验（parity odd），则跳转 PF == 0 23 JL 如果小于（less）则跳转 SF != OF 24 JNGE 如果不大于（not greater）或等于则跳转 SF != OF 25 JNL 如果不小于（not less）则跳转 SF == OF 26 JGE 如果大于（greater）或等于，则跳转 SF == OF 27 JLE 如果小于（less）或等于，则跳转 ZF == 1 || SF != OF 28 JNG 如果不大于（greater），则跳转 ZF == 1 || SF != OF 29 JNLE 如果不小于（not less）或等于，则跳转 ZF == 0 && SF == OF 30 JG 如果大于（greater），则跳转 ZF == 0 && SF == OF 31 JCXZJECXZJRCXZ 当 CX/ECX/RCX 寄存器为 0 时跳转 三条指令是一样的，只跳转8位偏移量 循环指令下面指令会将 CX/ECX/RCX 自动减去 1，如果 CX/ECX/RCX 不为 0 则跳转到指定的 8 位偏移标签。 序 号 指 令 描 述 其 他 1 LOOP CX/ECX/RCX != 0，则跳转 只有8位偏移 1 LOOPE / LOOPZ CX/ECX/RCX != 0，并且 ZF == 1，则跳转 只有8位偏移 1 LOOPNE / LOOPNZ CX/ECX/RCX != 0，并且 ZF == 0，则跳转 只有8位偏移 loop 指令有个灾难：如果将 CX/ECX/RCX 设置为 0，执行 loop 时会自动减去 1，就会变成 -1 回环，会陷入很长很长的循环。这时可以配合 JCXZ 指令判断 CX/ECX/RCX 为 0 则跳转来避免。 条件数据传送指令也可以利用标志位来达到按条件数据传送的功能指令。条件数据传送指令置限于寄存器与寄存器、或者寄存器与存储器之间的数据传送，不支持立即数传送。 对于使用无符号数的比较，则使用 above （A）和 below （B）关键字比较; 对于使用有符号数的比较，则使用 greater （G）和 less （L）关键字进行比较。 序 号 指 令 描 述 EFLAGS 1 CMOVO 如果溢出（overflow），则传送 OF == 1 2 CMOVNO 如果没溢出（not overflow），则传送 OF == 0 3 CMOVB 如果小于（below），则传送 CF == 1 4 CMOVC 如果 CF == 1，则传送 CF == 1 5 CMOVNAE 如果不大于（not above）或者等于，则传送 CF == 1 6 CMOVNB 如果不小于（not below），则传送 CF == 0 7 CMOVNC 如果 CF != 1，则传送 CF == 0 8 CMOVAE 如果大于（above）或等于，则传送 CF == 0 9 CMOVZ 如果 ZF == 1，则传送 ZF == 1 10 CMOVE 如果相等（equal），则传送 ZF == 1 11 CMOVNZ 如果 ZF != 1，则传送 ZF == 0 12 CMOVNE 如果不相等（not equal），则传送 ZF == 0 13 CMOVBE 如果小于（below）或等于，则传送 CF == 1 && ZF == 1 14 CMOVNA 如果不大于（not above），则传送 CF == 1 && ZF == 1 15 CMOVNBE 如果不小于（not below）或等于，则传送 CF == 0 && ZF == 0 16 CMOVA 如果大于（above），则传送 CF == 0 && ZF == 0 17 CMOVS 如果 SF == 1，则传送 SF == 1 18 CMOVNS 如果 SF == 0，则传送 SF == 0 19 CMOVP 如果奇偶检验（parity），则传送 PF == 1 20 CMOVPE 如果偶检验（parity even），则传送 PF == 1 21 CMOVNP 如果不奇偶检验（not parity），则传送 PF == 0 22 CMOVPO 如果奇检验（parity odd），则传送 PF == 0 23 CMOVL 如果小于（less）则传送 SF != OF 24 CMOVNGE 如果不大于（not greater）或等于则传送 SF != OF 25 CMOVNL 如果不小于（not less）则传送 SF == OF 26 CMOVGE 如果大于（greater）或等于，则传送 SF == OF 27 CMOVLE 如果小于（less）或等于，则传送 ZF == 1 || SF != OF 28 CMOVNG 如果不大于（greater），则传送 ZF == 1 || SF != OF 29 CMOVNLE 如果不小于（not less）或等于，则传送 ZF == 0 && SF == OF 30 CMOVG 如果大于（greater），则传送 ZF == 0 && SF == OF","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"x86汇编","slug":"技术文章/x86汇编","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/x86%E6%B1%87%E7%BC%96/"}],"tags":[{"name":"x86汇编","slug":"x86汇编","permalink":"https://www.code64.cn/blog1/tags/x86%E6%B1%87%E7%BC%96/"}]},{"title":"x86 AT&T 汇编语法基础与寻址方式","slug":"x86-AT-T-汇编语法基础与寻址方式","date":"2008-06-01T10:34:05.000Z","updated":"2022-02-24T14:35:47.194Z","comments":true,"path":"2008/06-01/EDB860F3795A04FCC604ED85765E85FF/","link":"","permalink":"https://www.code64.cn/blog1/2008/06-01/EDB860F3795A04FCC604ED85765E85FF/","excerpt":"","text":"数据定义段定义 .text 定义代码段 .data 定义数据段 .bss 定义未初始化数据段 .rodata 定义只读数据段 数据段（.data）定义数据元素 伪指令 数据类型 .ascii 文本字符串 .asciz 文本字符串（后面加\\0结尾） .byte 字节值（8位整数） .short 16位整数 .int 32位整数 .long 32位整数 .quad 64位整数 .octa 128位整数 .single 单精度浮点数（同.float） .float 单精度浮点数 .double 双精度浮点数 .globl 伪指令将标定义为全局可链接的，跨文件可以访问的符号。 代码样例： .globl msg # 将 msg 定义为全局的 pi: .float 3.14159 .long 100, 200, 300, 500, 400 msg: .asciz &quot;This is a text message.&quot; 定义未初始化数据（.bss段） .comm 定义全局的通用内存区域 .lcomm 定义局部的通用内存区域 格式如下： .comm symbol, length 代码样例： .section .bss .comm symbolName1, 10000 # 定义10000字节，符号名为 symbolName1 .lcomm symbolName2, 200 # 定义200字节，符号名为 symbolName2 定义静态符号使用 .equ 伪指令定义静态符号，也可以把它当作一个宏定义。格式举例： .equ LINUX_SYS_CALL, 0x80 movl $LINUX_SYS_CALL, %eax 立即数，数据传递方向与寄存器立即数所有数字前面加上美元符号，表示立即数，如 $100 表示十进制的 100 的立即数，$0x100 表示十六进制的 0x100 立即数。 数据传递方向数据传递方向为从左到右 （与 Intel 语法的从右到左相反） 寄存器寻址寄存器寻址需要在寄存器名称前面加上百分号 % 指令位宽涉及不同位宽的指令，需要在指令后面加上位宽后缀。 位宽后缀 数据位宽 b 8 位 w 16 位 l 32 位 q 64 位 代码样例： movl $0x12345678, %eax # 将立即数 0x12345678 传递给 EAX 寄存器 movb $al, %bl # 将寄存器 AL 的值复制给 BL 内存寻址方式1. 寄存器机器码中的 ModRM 字段中，mod == 11 时，r/m 表示为操作数为寄存器。 r/m 值 默认时 REX.B == 1 时 000 EAX / RAX R8 001 ECX / RCX R9 010 EDX / RDX R10 011 EBX / RBX R11 100 ESP / RSP R12 101 EBP / RBP R13 110 ESI / RSI R14 111 EDI / RDI R15 2. 直接寻址32位模式下，直接以数据段的标签来表示内存地址的方式，进行寻址。举例： .section .data data1: .int 0x12345678 .section .bss .comm data2, 8 .section .text movl data1, %eax # 直接用内存位置的标签 data1 来表示内存寻址 addl %eax, %eax movl %eax, data2 # 直接用内存位置的标签 data2 来表示内存寻址 标签值会最终会转化为一个 32 位的内存地址。 在 64 位 x86-64 模式下，不能再使用一个 32 位的内存地址值来进行寻址了。这个32位的标签值被重新释义为：相对于程序计算器（ PC ）的偏移。所以在 64 位模式下，出现了一种叫相对 PC 寻址，举例： .section .data data1: .int 0x12345678 .section .bss .comm data2, 8 .section .text movl data1(%rip), %eax # 直接用内存位置的标签 data1 来表示相对PC寻址 addl %eax, %eax movl %eax, data2(%rip) # 直接用内存位置的标签 data2 来表示相对PC寻址 机器码中的 ModRM 字段中，mod == 00，r/m == 101 时，表示为(1)直接寻址 或者 (2)相对 PC 寻址，指令会带一个32位的整数作为内存地址值。 3. 寄存器间接寻址将内存地址值存放在一个通用寄存器中，通过寄存器的值作为内存地址来间接访问内存的数据。用小括号把寄存器括起来表示，举例： movl %ebx, (%eax) # 32位下，(%eax) 表示将 EAX 寄存器里面的值作为内存地址进行寻址 movq %rbx, (%rax) # 64位下，(%rax) 表示将 RAX 寄存器里面的值作为内存地址进行寻址 机器码中的 ModRM 字段中，mod == 00 时，表示采用寄存器间接寻址； r/m 表示寄存器的值。 注：实际机器码中不存在 (%ebx) / (%rbx) / (%r13) 这种寄存器间接寻址，汇编器会自动把这类寄存器间接寻址加上一个 0 的偏移量。因为 ebx/rbx/r13 的 r/m 值为 101，而 mod == 00，r/m == 101 时表示为(1)直接寻址 或者 (2)相对 PC 寻址。请看下面的基址加偏移量寻址 4. 基址加偏移量寻址将寄存器中的值，加上一个 8 位或者 32 位有符号整数的偏移量，得到的和作为内存地址来访问内存的数据。将偏移量的值放在小括号外面，用小括号把寄存器括起来表示，举例： .section .text movl %ebx, 4(%edi) movl %eax, -8(%esi) movl %edx, 0x12345678(%eax) movl %ecx, values(%edx) .section .data values: .int 100, 200, 300 机器码中的 ModRM 字段中，当 r/m != 100 时， (1) mod == 01 时，表示采用 寄存器 + 8位偏移量， r/m表示对应寄存器； (2) mod == 10 时，表示采用 寄存器 + 32位偏移量， r/m表示对应寄存器。 注：实际机器码中不存在 (%esp) 或 value(%esp) 这类寻址，汇编器会自动把这 esp/rsp/r12 的间接寻址转换为下面的基址加变址寻址。因为 r/m == 100 时代表的 esp/rsp/r12 被表示为带 SIB 字段的基址加变址寻址，请参考下面的基址加变址寻址 5. 基址加变址寻址基址加变址寻址的表达式如下： 偏移量 (基址寄存器, 变址寄存器, 比例因子) 最终的内存地址值 EA = 基址寄存器值 + 变址寄存器 * 比例因子 + 偏移量比例因子只能为 1, 2, 4, 8 。 注： esp/rsp/r12 不能做变址寄存器 movl %eax, (%ebx, %ecx) # 没有比例因子时，默认比例因子为 1 movl %eax, (%ebx, %ecx, 4) # EA = ebx + ecx * 4 movl %eax, (%ebx, %ecx, 8) # EA = ebx + ecx * 8 movl %eax, values(, %edi, 4) # EA = values + edi * 4 movl %eax, (, %ecx, 8) # EA = ecx * 8 movl %eax, values(%esi, %edi, 4) # EA = values + esi + edi * 4 机器码中的 ModRM 字段中，当 r/m == 100 时，表示使用基址加变址寻址，具体参数由后继的 SIB 字节表示 (1) mod == 00 时，表示不带偏移量 (2) mod == 01 时，表示带 8 位偏移量 (3) mod == 10 时，表示带 32 位偏移量 ModRM 字段ModRM 字段为 1 字节，具体可以按下面位域分为 3 段。用于对指令的操作数或者寻址做出说明。 ModRM 字段： ┌───┬───┬───┬───┬───┬───┬───┬───┐ │ 7 │ 6 │ 5 │ 4 │ 3 │ 2 │ 1 │ 0 │ ├───┴───┼───┴───┴───┼───┴───┴───┤ │ mod │ reg │ r/m │ └───────┴───────────┴───────────┘ reg 域表示寄存器 r/m 域可以表示寄存器，也可以表示为内存寻址，具体由 mod 域决定 mod == 00 时，r/m 域为内存寻址，不加偏移量 mod == 01 时，r/m 域为内存寻址，带一个 8 位的偏移量 mod == 10 时，r/m 域为内存寻址，带一个 32 位的偏移量 mod == 11 时，r/m 域为寄存器 详细说明：（下面与64位来说明，32位下是同理只用低32位下的寄存器部分） 下表中，disp8 表示 8 位偏移量，disp32 表示 32 位偏移量 SIB 表示后面带一个叫 SIB 的 1 字节的字段，用这个字段来说明寻址方式 Mod 值 R/M 值 默认值（当REX.B == 0） 当REX.B == 1 时 00 000 (%rax) (%r8) 001 (%rcx) (%r9) 010 (%rdx) (%r10) 011 (%rbx) (%r11) 100 SIB SIB 101 disp32 或者 disp32(rip) disp32 或者 disp32(rip) 110 (%rsi) (%r14) 111 (%rdi) (%r15) 01 000 disp8(%rax) disp8(%r8) 001 disp8(%rcx) disp8(%r9) 010 disp8(%rdx) disp8(%r10) 011 disp8(%rbx) disp8(%r11) 100 disp8 + SIB disp8 + SIB 101 disp8(%rbp) disp8(%r13) 110 disp8(%rsi) disp8(%r14) 111 disp8(%rdi) disp8(%r15) 10 000 disp32(%rax) disp32(%r8) 001 disp32(%rcx) disp32(%r9) 010 disp32(%rdx) disp32(%r10) 011 disp32(%rbx) disp32(%r11) 100 disp32 + SIB disp32 + SIB 101 disp32(%rbp) disp32(%r13) 110 disp32(%rsi) disp32(%r14) 111 disp32(%rdi) disp32(%r15) 11 000 %rax %r8 001 %rcx %r9 010 %rdx %r10 011 %rbx %r11 100 %rsp %r12 101 %rbp %r13 110 %rsi %r14 111 %rdi %r15 特殊情况说明： 当 mod == 00 并且 r/m == 101 时，只使用一个 32 位的偏移量做寻址。32 位下为 32 位地址值，64 位下为相对程序计算器 PC 的偏移。 当 r/m = 100 时，表示后继带一个 SIB 的字节，用这个字节的信息来进行内存寻址。 SIB 字段SIB 字段为 1 字节，具体可以按下面位域分为 3 段。用于对指令的内存寻址做出说明。 SIB 字段： ┌───┬───┬───┬───┬───┬───┬───┬───┐ │ 7 │ 6 │ 5 │ 4 │ 3 │ 2 │ 1 │ 0 │ ├───┴───┼───┴───┴───┼───┴───┴───┤ │ scale │ index │ base │ └───────┴───────────┴───────────┘ scale 为比例因子，scale的值: 00 = 1， 01 = 2， 10 = 4， 11 = 8 index 为变址寄存器 base 为基址寄存器 注意： RSP/ESP 寄存器不能用于 index 变址寄存器，所以，当 index == 100 时，只存在基址寄存器 base，变址寄存器 index 和比例因子 scale 忽略不用；另外，R12 时可以用于index 变址寄存器的。 RBP/EBP/R13 寄存器默认是作为基址寄存器来使用，x86 要求RBP/EBP/R13 寄存器做基址寄存器时，必须带一个 8 位或者 32 位的偏移量。所以，如果 mod == 00，r/m == 100，base == 101时，base基址寄存器字段并不是表示 RBP/EBP/R13，而是要忽略这个基址寄存器，不存在基址寄存器，只存在变址寄存器，并把一个 32 位的偏移量作为基地址。所以出现以下形式的寻址： movl %eax, values(, %edi, 8) # 这里是忽略基地址寄存器，不需要基地址寄存器的情况 movl %eax, (, %edi, 8) # 忽略disp32的话，汇编器会默认加上一个为 0 的 disp32 值","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"x86汇编","slug":"技术文章/x86汇编","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/x86%E6%B1%87%E7%BC%96/"}],"tags":[{"name":"x86汇编","slug":"x86汇编","permalink":"https://www.code64.cn/blog1/tags/x86%E6%B1%87%E7%BC%96/"}]},{"title":"用 CPUID 指令获取处理器信息（书摘）","slug":"用-CPUID-指令获取处理器信息","date":"2008-06-01T03:44:35.000Z","updated":"2022-02-24T14:35:47.194Z","comments":true,"path":"2008/06-01/D927CA846C52D38BA0FB4927D159EC7D/","link":"","permalink":"https://www.code64.cn/blog1/2008/06-01/D927CA846C52D38BA0FB4927D159EC7D/","excerpt":"","text":"CPUID 程序CPUID 是一条获取 CPU 信息的指令，以寄存器 EAX 作为输入信息的参数，执行该指令之后，会输出具体结果到 EBX、ECX、EDX 寄存器上面，具体会输出什么信息，由输入参数寄存器 EAX 决定。 CPUID 指令具体使用的寄存器 EAX 的不同的输入选项如下所示： EAX值 CPUID 输出 0 厂商 ID字符串（Vendor ID）与支持的最大的 CPUID 选项值 1 处理器类型、系列、型号和步进信息 2 处理器缓存配置 3 处理器的序列号 4 缓存配置（线程数量、核心数量和物理属性） 5 监视信息 80000000h 扩展的厂商 ID 字符串和支持的级别 80000001h 扩展的处理器类型、系列、型号和步进信息 80000002h ~ 80000004h 扩展的处理器名称字符串 如果寄存器 EAX 输入 0， 则 EBX、ECX、EDX 寄存器输出如下： EBX 寄存器： 31 23 15 7 0 ┌─────────┬─────────┬─────────┬─────────┐ │ byte4 │ byte3 │ byte2 │ byte1 │ └─────────┴─────────┴─────────┴─────────┘ EDX 寄存器： 31 23 15 7 0 ┌─────────┬─────────┬─────────┬─────────┐ │ byte8 │ byte7 │ byte6 │ byte5 │ └─────────┴─────────┴─────────┴─────────┘ ECX 寄存器： 31 23 15 7 0 ┌─────────┬─────────┬─────────┬─────────┐ │ byte12 │ byte11 │ byte10 │ byte9 │ └─────────┴─────────┴─────────┴─────────┘ 把上面寄存器的值组成字符串即可。范例程序 (Linux下)： # cpuid.s .section .data output: .ascii &quot;The processor Vendor ID is &#39;xxxxxxxxxxxx&#39; \\n&quot; .section .text .globl _start _start: nop movl $0, %eax cpuid movl $output, %edi movl %ebx, 28(%edi) movl %edx, 32(%edi) movl %ecx, 36(%edi) movl $4, %eax movl $1, %ebx movl $output, %ecx movl $42, %edx int $0x80 movl $1, %eax movl $0, %ebx int $0x80 上面代码中，int $0x80 是调用 Linux 系统调用。_start 标签所定义的地址是 GNU 链接器默认的程序运行起始地址。 用下面命令进行编译、链接并运行 （要求在 32 位 x86 的 Linux 系统下，如果是 64 位系统的话，可以在虚拟机下面装一个 32 位的）： as -o cpuid.o cpuid.s ld -o cpuid cpuid.o # 运行： ./cpuid 结果： The processor Vendor ID is &#39;GenuineIntel&#39; 调试程序如果需要调试程序，则需要在编译的时候，加上 -gstabs 选项，会把调试信息直接附加进可执行二进制文件中： as -gstabs -o cpuid.o cpuid.s ld -o cpuid cpuid.o GDB 单步运行程序运行 gdb cpuid ： gdb cpuid GNU gdb Red Hat Linux (5.3post-0.20021129.18rh) Copyright 2003 Free Software Foundation, Inc. GDB is free software, covered by the GNU General Public License, and you are welcome to change it and/or distribute copies of it under certain conditions. Type &quot;show copying&quot; to see the conditions. There is absolutely no warranty for GDB. Type &quot;show warranty&quot; for details. This GDB was configured as &quot;i386-redhat-linux-gnu&quot;... (gdb) 使用 run 命令直接运行 cpuid 程序： (gdb) run Starting program: /root/Test/cpuid The processor Vendor ID is &#39;GenuineIntel&#39; Program exited normally. (gdb) 可以使用 break 命令设置断点，汇编语言设定断点，必须指定某个标签的相对位置。格式如下： break * label+offset gdb 会直接忽略 _start 这个标签的断点： (gdb) break * _start Breakpoint 1 at 0x8048074: file cpuid.s, line 9. (gdb) run Starting program: /root/Test/cpuid The processor Vendor ID is &#39;GenuineIntel&#39; Program exited normally. (gdb) 所以可以在 _start 标签之后直接加上一个 nop 指令，以这个nop指定作为断点，表示为 _start + 1，如下： (gdb) break * _start+1 Breakpoint 2 at 0x8048075: file cpuid.s, line 10. (gdb) run Starting program: /root/Test/cpuid Breakpoint 2, &lt;function called from gdb&gt; Current language: auto; currently asm (gdb) next 11 cpuid (gdb) next 12 movl $output, %edi (gdb) step 13 movl %ebx, 28(%edi) (gdb) step 14 movl %edx, 32(%edi) (gdb) cont Continuing. The processor Vendor ID is &#39;GenuineIntel&#39; Program exited normally. (gdb) 如上操作，设置断点之后，直接 run 命令可以运行程序，到达断点就暂停。这时，使用 next 或者 step 命令可以单步执行每条指令；使用 cont 命令可以继续以正常的方式继续执行。next 可以简化为 n；step 可以简化为 s；cont 可以简化为 c 查看数据 数据命令 说明 info registers 显示所有寄存器的值 print 显示特定寄存器或者来自程序的变量的值 print/d 同上，显示为十进制的值 print/t 同上，显示为二进制的值 print/x 同上，显示为十六进制的值 x 显示特定内存位置的值 查看寄存器： (gdb) run Starting program: /root/Test/cpuid Breakpoint 2, &lt;function called from gdb&gt; (gdb) s 11 cpuid (gdb) info registers eax 0x0 0 ecx 0x0 0 edx 0x0 0 ebx 0x0 0 esp 0xbfffeab0 0xbfffeab0 ebp 0x0 0x0 esi 0x0 0 edi 0x0 0 eip 0x804807a 0x804807a eflags 0x200306 2097926 cs 0x23 35 ss 0x2b 43 ds 0x2b 43 es 0x2b 43 fs 0x0 0 gs 0x0 0 (gdb) s 12 movl $output, %edi (gdb) info registers eax 0x16 22 ecx 0x6c65746e 1818588270 edx 0x49656e69 1231384169 ebx 0x756e6547 1970169159 esp 0xbfffeab0 0xbfffeab0 ebp 0x0 0x0 esi 0x0 0 edi 0x0 0 eip 0x804807c 0x804807c eflags 0x200306 2097926 cs 0x23 35 ss 0x2b 43 ds 0x2b 43 es 0x2b 43 fs 0x0 0 gs 0x0 0 (gdb) print/x $ebx $1 = 0x756e6547 (gdb) print/x $edx $2 = 0x49656e69 (gdb) print/x $ecx $3 = 0x6c65746e (gdb) x 命令用于查看内存位置的值。x 命令的格式为： x/nyz n 为需要显示的字段数。y 是输出格式，y 的值有： c 用于字符 d 用于十进制 x 用于十六进制 z 是要显示的字段的长度： b 用于字节 h 用于16位大小 w 用于32位大小 以下是显示 output 位置的内存的数据： (gdb) x/42cb &amp;output 0x80490ac &lt;output&gt;: 84 &#39;T&#39; 104 &#39;h&#39; 101 &#39;e&#39; 32 &#39; &#39; 112 &#39;p&#39; 114 &#39;r&#39; 111 &#39;o&#39; 99 &#39;c&#39; 0x80490b4 &lt;output+8&gt;: 101 &#39;e&#39; 115 &#39;s&#39; 115 &#39;s&#39; 111 &#39;o&#39; 114 &#39;r&#39; 32 &#39; &#39; 86 &#39;V&#39; 101 &#39;e&#39; 0x80490bc &lt;output+16&gt;: 110 &#39;n&#39; 100 &#39;d&#39; 111 &#39;o&#39; 114 &#39;r&#39; 32 &#39; &#39; 73 &#39;I&#39; 68 &#39;D&#39; 32 &#39; &#39; 0x80490c4 &lt;output+24&gt;: 105 &#39;i&#39; 115 &#39;s&#39; 32 &#39; &#39; 39 &#39;\\&#39;&#39; 120 &#39;x&#39; 120 &#39;x&#39; 120 &#39;x&#39; 120 &#39;x&#39; 0x80490cc &lt;output+32&gt;: 120 &#39;x&#39; 120 &#39;x&#39; 120 &#39;x&#39; 120 &#39;x&#39; 120 &#39;x&#39; 120 &#39;x&#39; 120 &#39;x&#39; 120 &#39;x&#39; 0x80490d4 &lt;output+40&gt;: 39 &#39;\\&#39;&#39; 32 &#39; &#39; (gdb) 与 C 语言库函数进行链接以上的系统调用方式改用为调用 C 语言函数库的方式，程序如下： # cpuid2.s .section .data output: .ascii &quot;The processor Vendor ID is &#39;%s&#39; \\n&quot; .section .bss .lcomm buffer, 16 # 在 .bss 中开辟一个16字节的未初始化数据缓冲区，标签为buffer .section .text .globl _start _start: nop movl $0, %eax cpuid movl $buffer, %edi movl %ebx, (%edi) movl %edx, 4(%edi) movl %ecx, 8(%edi) pushl $buffer pushl $output call printf # 调用 C 语言的 printf addl $8, %esp pushl $0 call exit # 调用 C 语言的 exit 编译方法： as -o cpuid2.o cpuid2.s ld -dynamic-linker /lib/ld-linux.so.2 -o cpuid2 -lc cpuid2.o # 运行： ./cpuid2 The processor Vendor ID is &#39;GenuineIntel&#39;","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"x86汇编","slug":"技术文章/x86汇编","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/x86%E6%B1%87%E7%BC%96/"}],"tags":[{"name":"x86汇编","slug":"x86汇编","permalink":"https://www.code64.cn/blog1/tags/x86%E6%B1%87%E7%BC%96/"}]},{"title":"C标准库之string.h - strxfrm","slug":"C标准库之string-h-strxfrm","date":"2008-05-02T15:18:06.000Z","updated":"2022-02-24T14:35:47.194Z","comments":true,"path":"2008/05-02/cstd-string-strxfrm/","link":"","permalink":"https://www.code64.cn/blog1/2008/05-02/cstd-string-strxfrm/","excerpt":"","text":"头文件： #include &lt;string.h&gt; xxxxxx 函数原型： void * __cdecl xxxxxx(const void * buf, int value, size_t maxcount); 作用/功能：","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"C_CPP","slug":"技术文章/C-CPP","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/C-CPP/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://www.code64.cn/blog1/tags/C-C/"}]},{"title":"C标准库之string.h - strtok","slug":"C标准库之string-h-strtok","date":"2008-05-02T15:09:07.000Z","updated":"2022-02-24T14:35:47.194Z","comments":true,"path":"2008/05-02/cstd-string-strtok/","link":"","permalink":"https://www.code64.cn/blog1/2008/05-02/cstd-string-strtok/","excerpt":"","text":"头文件： #include &lt;string.h&gt; xxxxxx 函数原型： void * __cdecl xxxxxx(const void * buf, int value, size_t maxcount); 作用/功能：","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"C_CPP","slug":"技术文章/C-CPP","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/C-CPP/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://www.code64.cn/blog1/tags/C-C/"}]},{"title":"C标准库之string.h - strstr","slug":"C标准库之string-h-strstr","date":"2008-05-02T14:56:54.000Z","updated":"2022-02-24T14:35:47.194Z","comments":true,"path":"2008/05-02/cstd-string-strstr/","link":"","permalink":"https://www.code64.cn/blog1/2008/05-02/cstd-string-strstr/","excerpt":"","text":"头文件： #include &lt;string.h&gt; xxxxxx 函数原型： void * __cdecl xxxxxx(const void * buf, int value, size_t maxcount); 作用/功能：","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"C_CPP","slug":"技术文章/C-CPP","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/C-CPP/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://www.code64.cn/blog1/tags/C-C/"}]},{"title":"C标准库之string.h - strspn","slug":"C标准库之string-h-strspn","date":"2008-05-02T14:40:05.000Z","updated":"2022-02-24T14:35:47.194Z","comments":true,"path":"2008/05-02/cstd-string-strspn/","link":"","permalink":"https://www.code64.cn/blog1/2008/05-02/cstd-string-strspn/","excerpt":"","text":"头文件： #include &lt;string.h&gt; xxxxxx 函数原型： void * __cdecl xxxxxx(const void * buf, int value, size_t maxcount); 作用/功能：","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"C_CPP","slug":"技术文章/C-CPP","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/C-CPP/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://www.code64.cn/blog1/tags/C-C/"}]},{"title":"C标准库之string.h - strrchr","slug":"C标准库之string-h-strrchr","date":"2008-05-02T14:21:34.000Z","updated":"2022-02-24T14:35:47.194Z","comments":true,"path":"2008/05-02/cstd-string-strrchr/","link":"","permalink":"https://www.code64.cn/blog1/2008/05-02/cstd-string-strrchr/","excerpt":"","text":"头文件： #include &lt;string.h&gt; xxxxxx 函数原型： void * __cdecl xxxxxx(const void * buf, int value, size_t maxcount); 作用/功能：","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"C_CPP","slug":"技术文章/C-CPP","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/C-CPP/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://www.code64.cn/blog1/tags/C-C/"}]},{"title":"C标准库之string.h - strpbrk","slug":"C标准库之string-h-strpbrk","date":"2008-05-02T13:49:56.000Z","updated":"2022-02-24T14:35:47.194Z","comments":true,"path":"2008/05-02/cstd-string-strpbrk/","link":"","permalink":"https://www.code64.cn/blog1/2008/05-02/cstd-string-strpbrk/","excerpt":"","text":"头文件： #include &lt;string.h&gt; xxxxxx 函数原型： void * __cdecl xxxxxx(const void * buf, int value, size_t maxcount); 作用/功能：","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"C_CPP","slug":"技术文章/C-CPP","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/C-CPP/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://www.code64.cn/blog1/tags/C-C/"}]},{"title":"C标准库之string.h - strndup","slug":"C标准库之string-h-strndup","date":"2008-05-02T13:39:59.000Z","updated":"2022-02-24T14:35:47.194Z","comments":true,"path":"2008/05-02/cstd-string-strndup/","link":"","permalink":"https://www.code64.cn/blog1/2008/05-02/cstd-string-strndup/","excerpt":"","text":"头文件： #include &lt;string.h&gt; xxxxxx 函数原型： void * __cdecl xxxxxx(const void * buf, int value, size_t maxcount); 作用/功能：","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"C_CPP","slug":"技术文章/C-CPP","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/C-CPP/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://www.code64.cn/blog1/tags/C-C/"}]},{"title":"C标准库之string.h - strncpy","slug":"C标准库之string-h-strncpy","date":"2008-05-02T13:33:33.000Z","updated":"2022-02-24T14:35:47.194Z","comments":true,"path":"2008/05-02/cstd-string-strncpy/","link":"","permalink":"https://www.code64.cn/blog1/2008/05-02/cstd-string-strncpy/","excerpt":"","text":"头文件： #include &lt;string.h&gt; xxxxxx 函数原型： void * __cdecl xxxxxx(const void * buf, int value, size_t maxcount); 作用/功能：","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"C_CPP","slug":"技术文章/C-CPP","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/C-CPP/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://www.code64.cn/blog1/tags/C-C/"}]},{"title":"C标准库之string.h - strncmp","slug":"C标准库之string-h-strncmp","date":"2008-05-02T12:21:18.000Z","updated":"2022-02-24T14:35:47.194Z","comments":true,"path":"2008/05-02/cstd-string-strncmp/","link":"","permalink":"https://www.code64.cn/blog1/2008/05-02/cstd-string-strncmp/","excerpt":"","text":"头文件： #include &lt;string.h&gt; xxxxxx 函数原型： void * __cdecl xxxxxx(const void * buf, int value, size_t maxcount); 作用/功能：","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"C_CPP","slug":"技术文章/C-CPP","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/C-CPP/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://www.code64.cn/blog1/tags/C-C/"}]},{"title":"C标准库之string.h - strncat","slug":"C标准库之string-h-strncat","date":"2008-05-02T11:09:59.000Z","updated":"2022-02-24T14:35:47.194Z","comments":true,"path":"2008/05-02/cstd-string-strncat/","link":"","permalink":"https://www.code64.cn/blog1/2008/05-02/cstd-string-strncat/","excerpt":"","text":"头文件： #include &lt;string.h&gt; xxxxxx 函数原型： void * __cdecl xxxxxx(const void * buf, int value, size_t maxcount); 作用/功能：","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"C_CPP","slug":"技术文章/C-CPP","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/C-CPP/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://www.code64.cn/blog1/tags/C-C/"}]},{"title":"C标准库之string.h - strlen","slug":"C标准库之string-h-strlen","date":"2008-05-02T10:50:00.000Z","updated":"2022-02-24T14:35:47.194Z","comments":true,"path":"2008/05-02/cstd-string-strlen/","link":"","permalink":"https://www.code64.cn/blog1/2008/05-02/cstd-string-strlen/","excerpt":"","text":"头文件： #include &lt;string.h&gt; xxxxxx 函数原型： void * __cdecl xxxxxx(const void * buf, int value, size_t maxcount); 作用/功能：","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"C_CPP","slug":"技术文章/C-CPP","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/C-CPP/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://www.code64.cn/blog1/tags/C-C/"}]},{"title":"C标准库之string.h - strerror","slug":"C标准库之string-h-strerror","date":"2008-05-02T10:32:10.000Z","updated":"2022-02-24T14:35:47.194Z","comments":true,"path":"2008/05-02/cstd-string-strerror/","link":"","permalink":"https://www.code64.cn/blog1/2008/05-02/cstd-string-strerror/","excerpt":"","text":"头文件： #include &lt;string.h&gt; xxxxxx 函数原型： void * __cdecl xxxxxx(const void * buf, int value, size_t maxcount); 作用/功能：","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"C_CPP","slug":"技术文章/C-CPP","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/C-CPP/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://www.code64.cn/blog1/tags/C-C/"}]},{"title":"C标准库之string.h - strdup","slug":"C标准库之string-h-strdup","date":"2008-05-02T07:55:45.000Z","updated":"2022-02-24T14:35:47.194Z","comments":true,"path":"2008/05-02/cstd-string-strdup/","link":"","permalink":"https://www.code64.cn/blog1/2008/05-02/cstd-string-strdup/","excerpt":"","text":"头文件： #include &lt;string.h&gt; xxxxxx 函数原型： void * __cdecl xxxxxx(const void * buf, int value, size_t maxcount); 作用/功能：","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"C_CPP","slug":"技术文章/C-CPP","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/C-CPP/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://www.code64.cn/blog1/tags/C-C/"}]},{"title":"C标准库之string.h - strcspn","slug":"C标准库之string-h-strcspn","date":"2008-05-02T07:26:03.000Z","updated":"2022-02-24T14:35:47.194Z","comments":true,"path":"2008/05-02/cstd-string-strcspn/","link":"","permalink":"https://www.code64.cn/blog1/2008/05-02/cstd-string-strcspn/","excerpt":"","text":"头文件： #include &lt;string.h&gt; xxxxxx 函数原型： void * __cdecl xxxxxx(const void * buf, int value, size_t maxcount); 作用/功能：","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"C_CPP","slug":"技术文章/C-CPP","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/C-CPP/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://www.code64.cn/blog1/tags/C-C/"}]},{"title":"C标准库之string.h - strcpy","slug":"C标准库之string-h-strcpy","date":"2008-05-02T06:52:02.000Z","updated":"2022-02-24T14:35:47.194Z","comments":true,"path":"2008/05-02/cstd-string-strcpy/","link":"","permalink":"https://www.code64.cn/blog1/2008/05-02/cstd-string-strcpy/","excerpt":"","text":"头文件： #include &lt;string.h&gt; xxxxxx 函数原型： void * __cdecl xxxxxx(const void * buf, int value, size_t maxcount); 作用/功能：","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"C_CPP","slug":"技术文章/C-CPP","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/C-CPP/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://www.code64.cn/blog1/tags/C-C/"}]},{"title":"C标准库之string.h - strcoll","slug":"C标准库之string-h-strcoll","date":"2008-05-02T06:28:53.000Z","updated":"2022-02-24T14:35:47.194Z","comments":true,"path":"2008/05-02/cstd-string-strcoll/","link":"","permalink":"https://www.code64.cn/blog1/2008/05-02/cstd-string-strcoll/","excerpt":"","text":"头文件： #include &lt;string.h&gt; xxxxxx 函数原型： void * __cdecl xxxxxx(const void * buf, int value, size_t maxcount); 作用/功能：","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"C_CPP","slug":"技术文章/C-CPP","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/C-CPP/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://www.code64.cn/blog1/tags/C-C/"}]},{"title":"C标准库之string.h - strcmp","slug":"C标准库之string-h-strcmp","date":"2008-05-02T06:08:22.000Z","updated":"2022-02-24T14:35:47.194Z","comments":true,"path":"2008/05-02/cstd-string-strcmp/","link":"","permalink":"https://www.code64.cn/blog1/2008/05-02/cstd-string-strcmp/","excerpt":"","text":"头文件： #include &lt;string.h&gt; xxxxxx 函数原型： void * __cdecl xxxxxx(const void * buf, int value, size_t maxcount); 作用/功能：","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"C_CPP","slug":"技术文章/C-CPP","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/C-CPP/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://www.code64.cn/blog1/tags/C-C/"}]},{"title":"C标准库之string.h - strchr","slug":"C标准库之string-h-strchr","date":"2008-05-02T05:29:59.000Z","updated":"2022-02-24T14:35:47.179Z","comments":true,"path":"2008/05-02/cstd-string-strchr/","link":"","permalink":"https://www.code64.cn/blog1/2008/05-02/cstd-string-strchr/","excerpt":"","text":"头文件： #include &lt;string.h&gt; xxxxxx 函数原型： void * __cdecl xxxxxx(const void * buf, int value, size_t maxcount); 作用/功能：","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"C_CPP","slug":"技术文章/C-CPP","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/C-CPP/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://www.code64.cn/blog1/tags/C-C/"}]},{"title":"C标准库之string.h - strcat","slug":"C标准库之string-h-strcat","date":"2008-05-02T05:28:03.000Z","updated":"2022-02-24T14:35:47.179Z","comments":true,"path":"2008/05-02/cstd-string-strcat/","link":"","permalink":"https://www.code64.cn/blog1/2008/05-02/cstd-string-strcat/","excerpt":"","text":"头文件： #include &lt;string.h&gt; xxxxxx 函数原型： void * __cdecl xxxxxx(const void * buf, int value, size_t maxcount); 作用/功能：","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"C_CPP","slug":"技术文章/C-CPP","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/C-CPP/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://www.code64.cn/blog1/tags/C-C/"}]},{"title":"C标准库之string.h - memchr","slug":"C标准库之string-h-memchr","date":"2008-05-02T05:22:13.000Z","updated":"2022-02-24T14:35:47.179Z","comments":true,"path":"2008/05-02/cstd-string-memchr/","link":"","permalink":"https://www.code64.cn/blog1/2008/05-02/cstd-string-memchr/","excerpt":"","text":"头文件： #include &lt;string.h&gt; memchr 函数原型： void * __cdecl memchr(const void * buf, int value, size_t maxcount); 作用/功能： 从 buf 所指定内存区域中的前 maxcount 个字节查找 value 值的字符。 返回值：返回找到的字符的指针，如果找不到，则返回 NULL。","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"C_CPP","slug":"技术文章/C-CPP","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/C-CPP/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://www.code64.cn/blog1/tags/C-C/"}]},{"title":"C标准库之string.h - memset","slug":"C标准库之string-h-memset","date":"2008-05-02T01:02:23.000Z","updated":"2022-02-24T14:35:47.179Z","comments":true,"path":"2008/05-02/cstd-string-memset/","link":"","permalink":"https://www.code64.cn/blog1/2008/05-02/cstd-string-memset/","excerpt":"","text":"头文件： #include &lt;string.h&gt; xxxxxx 函数原型： void * __cdecl xxxxxx(const void * buf, int value, size_t maxcount); 作用/功能：","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"C_CPP","slug":"技术文章/C-CPP","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/C-CPP/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://www.code64.cn/blog1/tags/C-C/"}]},{"title":"C标准库之string.h - memmove","slug":"C标准库之string-h-memmove","date":"2008-05-02T00:59:03.000Z","updated":"2022-02-24T14:35:47.179Z","comments":true,"path":"2008/05-02/cstd-string-memmove/","link":"","permalink":"https://www.code64.cn/blog1/2008/05-02/cstd-string-memmove/","excerpt":"","text":"头文件： #include &lt;string.h&gt; xxxxxx 函数原型： void * __cdecl xxxxxx(const void * buf, int value, size_t maxcount); 作用/功能：","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"C_CPP","slug":"技术文章/C-CPP","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/C-CPP/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://www.code64.cn/blog1/tags/C-C/"}]},{"title":"C标准库之string.h - memcpy","slug":"C标准库之string-h-memcpy","date":"2008-05-02T00:42:53.000Z","updated":"2022-02-24T14:35:47.179Z","comments":true,"path":"2008/05-02/cstd-string-memcpy/","link":"","permalink":"https://www.code64.cn/blog1/2008/05-02/cstd-string-memcpy/","excerpt":"","text":"头文件： #include &lt;string.h&gt; xxxxxx 函数原型： void * __cdecl xxxxxx(const void * buf, int value, size_t maxcount); 作用/功能：","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"C_CPP","slug":"技术文章/C-CPP","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/C-CPP/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://www.code64.cn/blog1/tags/C-C/"}]},{"title":"C标准库之string.h - memcmp","slug":"C标准库之string-h-memcmp","date":"2008-05-02T00:22:13.000Z","updated":"2022-02-24T14:35:47.179Z","comments":true,"path":"2008/05-02/cstd-string-memcmp/","link":"","permalink":"https://www.code64.cn/blog1/2008/05-02/cstd-string-memcmp/","excerpt":"","text":"头文件： #include &lt;string.h&gt; xxxxxx 函数原型： void * __cdecl xxxxxx(const void * buf, int value, size_t maxcount); 作用/功能：","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"C_CPP","slug":"技术文章/C-CPP","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/C-CPP/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://www.code64.cn/blog1/tags/C-C/"}]},{"title":"C标准库之string.h - memccpy","slug":"C标准库之string-h-memccpy","date":"2008-05-02T00:12:43.000Z","updated":"2022-02-24T14:35:47.179Z","comments":true,"path":"2008/05-02/cstd-string-memccpy/","link":"","permalink":"https://www.code64.cn/blog1/2008/05-02/cstd-string-memccpy/","excerpt":"","text":"头文件： #include &lt;string.h&gt; xxxxxx 函数原型： void * __cdecl xxxxxx(const void * buf, int value, size_t maxcount); 作用/功能：","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"C_CPP","slug":"技术文章/C-CPP","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/C-CPP/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://www.code64.cn/blog1/tags/C-C/"}]},{"title":"C99 中的 restrict 限定符","slug":"C99-中的-restrict-限定符","date":"2008-05-01T03:47:43.000Z","updated":"2022-02-24T14:35:47.179Z","comments":true,"path":"2008/05-01/B099BE7A08235BB201EA63959886F404/","link":"","permalink":"https://www.code64.cn/blog1/2008/05-01/B099BE7A08235BB201EA63959886F404/","excerpt":"","text":"C99 标准中，给 C 语言引入了 restrict 限定符，与 const 和 volatile 不同的是，restrict 限定符只能修饰指针。 restrict 限定符告诉编译器，该指针指向的对象，只能通过该指针进行唯一引用，不能通过别的指针直接或者间接的方式进行修改该对象。restrict 限定符可以让编译器对指针操作进行放心的优化，以提升性能。 举以下例子说明，以得到一个详细的认知： #include &lt;stdio.h&gt; unsigned exData; int main() &#123; unsigned * p1 = &amp;exData; unsigned char * p2 = (unsigned char *) &amp;exData; *p1 = 0x12345678; *p2 = 0xFF; *p1 = 0x9ABCDEF; *p2 = 0xFE; printf(&quot;%08x&quot;, *p1); return 0; &#125; 上述例子中，指针 p1 和 p2 指向的对象出现了叠交现象。通过 p1 进行修改，和通过 p2 进行修改，都会影响到指向的对象。 在编译器优化的层面上，频繁进行读写的变量，可能会优先只存在于寄存器的快照中。上述例子中，*p1 和 *p2，是叠交的，如果过度优化只存在与寄存器的快照中的话，修改 *p1 等于只写入了 寄存器 A，修改 *p2 等于只写入了 寄存器 B，这样就会得到一个错误的结果。所以编译器对于指针操作不能做过度的优化。 restrict 限定符就是告诉编译器，该指针是指向该对象的唯一途径，可以放心地进行优化。 // 内存复制的函数例子： // 通过 restrict 来指明 s1 与 s2 指向的两块内存不相交 void * memcpy（void * restrict s1, const void * restrict s2, size_t n) &#123; // 这里可以放心对 s1 和 s2 指向的操作进行优化而不担心出现错误 // 例如在 64 位的 CPU 下内存复制可以优化为每 8 字节复制一次 &#125;","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"C_CPP","slug":"技术文章/C-CPP","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/C-CPP/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://www.code64.cn/blog1/tags/C-C/"}]},{"title":"个人博客安家了，家乡的红薯地上发来贺电","slug":"个人博客安家了，家乡的红薯地上发来贺电","date":"2008-04-21T12:51:56.000Z","updated":"2022-02-24T14:35:47.194Z","comments":true,"path":"2008/04-21/72595F19927B4B63DC6C0C9CB94A889A/","link":"","permalink":"https://www.code64.cn/blog1/2008/04-21/72595F19927B4B63DC6C0C9CB94A889A/","excerpt":"","text":"当发现自己的才华撑不起野心时，就请安静下来学习吧. int main() &#123; return printf(&quot;Hello World!&quot;); &#125;","categories":[{"name":"生活随笔","slug":"生活随笔","permalink":"https://www.code64.cn/blog1/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"杂项","slug":"杂项","permalink":"https://www.code64.cn/blog1/tags/%E6%9D%82%E9%A1%B9/"},{"name":"随笔","slug":"随笔","permalink":"https://www.code64.cn/blog1/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Hello World","slug":"hello-world","date":"2008-04-20T15:57:02.000Z","updated":"2022-02-24T14:35:47.194Z","comments":true,"path":"2008/04-20/D17DB8E49089281A43B3A2A2BA5FEC49/","link":"","permalink":"https://www.code64.cn/blog1/2008/04-20/D17DB8E49089281A43B3A2A2BA5FEC49/","excerpt":"","text":"Hello World 中文意思是『你好，世界』。因为 The C Programming Language 中使用它做为第一个演示程序，非常著名，所以后来的程序员在学习编程或进行设备调试时延续了这一习惯。","categories":[{"name":"生活随笔","slug":"生活随笔","permalink":"https://www.code64.cn/blog1/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"杂项","slug":"杂项","permalink":"https://www.code64.cn/blog1/tags/%E6%9D%82%E9%A1%B9/"},{"name":"随笔","slug":"随笔","permalink":"https://www.code64.cn/blog1/tags/%E9%9A%8F%E7%AC%94/"}]}],"categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"Linux","slug":"技术文章/Linux","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Linux/"},{"name":"Win32","slug":"技术文章/Win32","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Win32/"},{"name":"JavaScript","slug":"技术文章/JavaScript","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/JavaScript/"},{"name":"Rust","slug":"技术文章/Rust","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Rust/"},{"name":"C_CPP","slug":"技术文章/C-CPP","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/C-CPP/"},{"name":"CSharp","slug":"技术文章/CSharp","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/CSharp/"},{"name":"React","slug":"技术文章/React","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/React/"},{"name":"Objective-C","slug":"技术文章/Objective-C","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Objective-C/"},{"name":"Swift","slug":"技术文章/Swift","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Swift/"},{"name":"Java","slug":"技术文章/Java","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Java/"},{"name":"x86汇编","slug":"技术文章/x86汇编","permalink":"https://www.code64.cn/blog1/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/x86%E6%B1%87%E7%BC%96/"},{"name":"生活随笔","slug":"生活随笔","permalink":"https://www.code64.cn/blog1/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.code64.cn/blog1/tags/Linux/"},{"name":"Win32","slug":"Win32","permalink":"https://www.code64.cn/blog1/tags/Win32/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.code64.cn/blog1/tags/JavaScript/"},{"name":"Rust","slug":"Rust","permalink":"https://www.code64.cn/blog1/tags/Rust/"},{"name":"C/C++","slug":"C-C","permalink":"https://www.code64.cn/blog1/tags/C-C/"},{"name":"C#","slug":"C","permalink":"https://www.code64.cn/blog1/tags/C/"},{"name":"React","slug":"React","permalink":"https://www.code64.cn/blog1/tags/React/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://www.code64.cn/blog1/tags/Objective-C/"},{"name":"Swift","slug":"Swift","permalink":"https://www.code64.cn/blog1/tags/Swift/"},{"name":"Java","slug":"Java","permalink":"https://www.code64.cn/blog1/tags/Java/"},{"name":"x86汇编","slug":"x86汇编","permalink":"https://www.code64.cn/blog1/tags/x86%E6%B1%87%E7%BC%96/"},{"name":"杂项","slug":"杂项","permalink":"https://www.code64.cn/blog1/tags/%E6%9D%82%E9%A1%B9/"},{"name":"随笔","slug":"随笔","permalink":"https://www.code64.cn/blog1/tags/%E9%9A%8F%E7%AC%94/"}]}